<!DOCTYPE html>
<html lang="ko">

    <head>
        <meta charset="UTF-8">
        <title>ë¯¸ë¡œ ê²Œì„</title>

        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Cute+Font&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Gothic+A1&family=IBM+Plex+Sans+KR&display=swap"
              rel="stylesheet">
        <style>
            body {
                font-family: 'Noto Sans KR', sans-serif;
                text-align: center;
                background: #f9f9f9;
                margin: 0;
                padding: 20px;
            }

            canvas {
                border: 5px solid rgb(8, 98, 158);
                background: #fff;
                margin-top: 10px;
                border-radius: 0.75rem;
                touch-action: none;
            }

            button {
                padding: 10px 20px;
                margin: 10px;
                font-size: 1rem;
                border-radius: 10px;
                border: none;
                color: white;
                cursor: pointer;
                white-space: nowrap;
                background-color: #3498db;
            }

            button:hover {
                background-color: #2980b9;
            }

            button:disabled {
                background-color: #ccc;
                cursor: not-allowed;
            }

            select {
                -webkit-appearance: none;
                -moz-appearance: none;
                font-size: 1rem;
                margin: 0 0.5rem;
                appearance: none;
                padding: 10px;
                width: 150px;
                cursor: pointer;
            }

            .cute-font-regular {
                font-family: "Cute Font", sans-serif;
                font-weight: 400;
                font-style: normal;
            }

            #scoreDisplay,
            #timeDisplay,
            #resultMsg {
                font-weight: bold;
                color: darkblue;
                font-size: 1.2rem;
            }

            #loadingOverlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background-color: rgba(255, 255, 255, 0.7);
                z-index: 10;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            .loader {
                border: 8px solid #f3f3f3;
                border-top: 8px solid #3498db;
                border-radius: 50%;
                width: 60px;
                height: 60px;
                animation: spin 1s linear infinite;
            }

            .hidden {
                display: none !important;
            }

            .shake {
                animation: shake 0.3s;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }

                100% {
                    transform: rotate(360deg);
                }
            }

            @keyframes shake {
                0% {
                    transform: translate(2px, 2px);
                }

                25% {
                    transform: translate(-2px, -2px);
                }

                50% {
                    transform: translate(2px, -2px);
                }

                75% {
                    transform: translate(-2px, 2px);
                }

                100% {
                    transform: translate(0, 0);
                }
            }
        </style>
    </head>

    <body>
        <div style="overflow: scroll;">
            <h1>ğŸ® ì •ë‹µ ê¸°ë°˜ ë¯¸ë¡œ ê²Œì„</h1>
            <div style="display: flex; gap: 1rem;
                        align-items: center;
                        justify-content: center;
                        width: 100vw;">
                <div style="width: 300px; display: flex; align-items: center; justify-content: center;">
                    <label style="font-size: 1.3rem; color: #454545;">ë‚œì´ë„ </label>
                    <select id="levelSelect"></select>
                </div>
                <button onclick="startGame()" id="startGameBtn">ê²Œì„ ì‹œì‘</button>
                <button onclick="stopGame()" id="stopGameBtn">ê²Œì„ ì¤‘ì§€</button>
                <button onclick="showAnswerPath()" id="showPathBtn">ì •ë‹µ í™•ì¸</button>
                <button onclick="hideAnswerPath()" id="hidePathBtn">ì •ë‹µ ìˆ¨ê¸°ê¸°</button>
            </div>
            <div style="display: flex; justify-content: center; gap: 2rem; margin: 1rem 0;">
                <p id="scoreDisplay">ğŸ† ì ìˆ˜: 0</p>
                <p id="timeDisplay">â³ ë‚¨ì€ ì‹œê°„: 0ì´ˆ</p>
            </div>
            <div id="loadingOverlay" class="hidden">
                <div class="loader"></div>
            </div>
            <canvas id="maze" width="1000" height="760"></canvas>
            <p id="resultMsg"></p>
        </div>

        <script>
            // --- ì¶œì œ  ë¬¸ì œ  ---
            const answersList = [
                "ë¬´ì†Œì˜ ë¿”ì²˜ëŸ¼ í˜¼ìì„œ ê°€ë¼",
                "ê°™ì€ ë¬¼ì´ë¼ë„ ì†Œê°€ ë§ˆì‹œë©´ ì –ì´ ë˜ê³  ë±€ì´ ë§ˆì‹œë©´ ë…ì´ëœë‹¤",
                "ì‚¬ëŒì€ ë¨¼ì € ìê¸° ìì‹ ì„ ê°€ë¥´ì³ì•¼ í•œë‹¤ ê·¸ë˜ì•¼ë§Œ ê·¸ëŠ” ë‚¨ë“¤ì„ ê°€ë¥´ì¹  ìˆ˜ ìˆë‹¤",
                "ì–´ë–¤ ë°”ë³´ë¼ë„ ì»´í“¨í„°ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤ ê·¸ë˜ì„œ ë§ì€ ì‚¬ëŒë“¤ì´ ì»´í“¨í„°ë¥¼ ì‚¬ìš©í•œë‹¤",
                "ì„¸ìƒì—ëŠ” ë”± ë‘ê°€ì§€ í”„ë¡œê·¸ë˜ë° ì–¸ì–´ê°€ ìˆë‹¤ ì‚¬ëŒë“¤ì´ ìš•í•˜ëŠ” ì–¸ì–´ì™€ ì•„ë¬´ë„ ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” ì–¸ì–´",
                "ì¢‹ì€ í”„ë¡œê·¸ë˜ë¨¸ ëŒ€ë¶€ë¶„ì€ ëˆì´ë‚˜ ëŒ€ì¤‘ì—ê²Œ ë°›ì„ ì°¬ì‚¬ë¥¼ ê¸°ëŒ€í•˜ê³  í”„ë¡œê·¸ë˜ë°ì„ í•˜ì§€ ì•Šê³  ì¬ë¯¸ ìˆì–´ì„œ í•œë‹¤",
                "ê±´ê°•ì€ ìµœìƒì˜ ì´ìµ ë§Œì¡±ì€ ìµœìƒì˜ ì¬ì‚° ì‹ ë¢°ëŠ” ìµœìƒì˜ ì¸ì—°ì´ë‹¤ ê·¸ëŸ¬ë‚˜ ë§ˆìŒì˜ í‰í•œë³´ë‹¤ ë” í–‰ë³µí•œ ê²ƒì€ ì—†ë‹¤",
                "ë‚˜ëŠ” ë“œë””ì–´ ìƒìœ„í˜¸í™˜ì„±ì˜ ì˜ë¯¸í•˜ëŠ” ë°”ë¥¼ ê¹¨ë‹¬ì•˜ë‹¤ ê·¸ê²ƒì€ ì˜›ë‚ ì— ë§Œë“  ì‹¤ìˆ˜ê¹Œì§€ ê·¸ëŒ€ë¡œ ìœ ì§€í•´ì•¼ í•œë‹¤ëŠ” ëœ»ì´ë‹¤ ì œê¸¸",
                "ì†ìœ¼ë¡œ ì‹­ì´ˆë©´ ì¶©ë¶„íˆ í•  ìˆ˜ ìˆëŠ” ì¼ì„ ì»´í“¨í„°ë¡œ í•˜ë£¨ ì¢…ì¼ í”„ë¡œê·¸ë˜ë°í•´ì„œ ìë™ìœ¼ë¡œ ìˆ˜í–‰í•  ë•Œ ë‚˜ëŠ” ë”í•  ë‚˜ìœ„ ì—†ì´ í° í–‰ë³µì„ ëŠë‚€ë‹¤",
                "ë‚˜ëŠ” ì»´í“¨í„°ê°€ ë˜‘ë˜‘í•´ì ¸ì„œ ì„¸ê³„ë¥¼ ì§€ë°°í•  ê±°ë¼ëŠ” ê³µí¬ê°€ ê±°ì˜ ëª¨ë“  ì„¸ê³„ì—ì„œ ì‚¬ë¼ì¡Œë‹¤ëŠ” ê±¸ ì•Œê²Œ ë˜ì—ˆë‹¤ ì •í™•íˆ ìœˆë„ìš° ë°°í¬ ì‹œì ê³¼ ì¼ì¹˜í•œë‹¤",
            ];

            let LEVEL_TIME_LIMITS = [];
            let answer = "";
            let COLS, ROWS, CELL;
            const canvas = document.getElementById("maze");
            const ctx = canvas.getContext("2d");
            let player = { x: 0, y: 0 };
            let grid = [];
            let path = [];
            let letters = [];
            let moveStack = [];
            let showPath = false;
            let interval = null;
            let visitedCells = new Set();
            let score = 0;
            let remainingTime = 0;
            let isGameActive = false;
            let answerLetterCoords = new Set();
            let collectedLetterCoords = new Set();
            let totalAnswerLetters = 0;

            // --- ì´ˆê¸° ì„¤ì • í•¨ìˆ˜ ---
            function setupLevels() {
                const select = document.getElementById("levelSelect");
                const length = answersList.length;
                for (let i = 1; i <= length; i++) {
                    const opt = document.createElement("option");
                    opt.value = i;
                    opt.innerText = `${i}ë‹¨ê³„`;
                    select.appendChild(opt);
                }
                select.value = 1;
            }
            document.addEventListener("DOMContentLoaded", setupLevels);

            // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---
            function index(i, j) {
                if (i < 0 || j < 0 || i >= COLS || j >= ROWS) return -1;
                return i + j * COLS;
            }

            // --- ë¯¸ë¡œ ìƒì„± ê´€ë ¨ í•¨ìˆ˜ ---
            function Cell(i, j) {
                this.i = i;
                this.j = j;
                this.walls = [true, true, true, true];
                this.visited = false;
            }

            function removeWalls(a, b) {
                let dx = a.i - b.i;
                let dy = a.j - b.j;
                if (dx == 1) { a.walls[3] = false; b.walls[1] = false; }
                if (dx == -1) { a.walls[1] = false; b.walls[3] = false; }
                if (dy == 1) { a.walls[0] = false; b.walls[2] = false; }
                if (dy == -1) { a.walls[2] = false; b.walls[0] = false; }
            }

            function openExtraPaths(probability = 0.2) {
                for (let c of grid) {
                    if (Math.random() < probability) {
                        const neighbors = [];
                        let top = grid[index(c.i, c.j - 1)];
                        let right = grid[index(c.i + 1, c.j)];
                        let bottom = grid[index(c.i, c.j + 1)];
                        let left = grid[index(c.i - 1, c.j)];
                        if (top && c.walls[0]) neighbors.push({ dir: 0, cell: top });
                        if (right && c.walls[1]) neighbors.push({ dir: 1, cell: right });
                        if (bottom && c.walls[2]) neighbors.push({ dir: 2, cell: bottom });
                        if (left && c.walls[3]) neighbors.push({ dir: 3, cell: left });
                        if (neighbors.length > 0) {
                            const { dir, cell: neighbor } = neighbors[Math.floor(Math.random() * neighbors.length)];
                            c.walls[dir] = false;
                            neighbor.walls[(dir + 2) % 4] = false;
                        }
                    }
                }
            }

            function generateMaze(callback) {
                grid = [];
                for (let j = 0; j < ROWS; j++) {
                    for (let i = 0; i < COLS; i++) {
                        grid.push(new Cell(i, j));
                    }
                }
                let current = grid[0];
                current.visited = true;
                let stack = [];
                const batchSize = 150;

                function stepBatch() {
                    let stepsInBatch = 0;
                    while (stepsInBatch < batchSize) {
                        let neighbors = [];
                        let top = grid[index(current.i, current.j - 1)];
                        let right = grid[index(current.i + 1, current.j)];
                        let bottom = grid[index(current.i, current.j + 1)];
                        let left = grid[index(current.i - 1, current.j)];
                        [top, right, bottom, left].forEach(n => { if (n && !n.visited) neighbors.push(n); });

                        if (neighbors.length > 0) {
                            stack.push(current);
                            let next = neighbors[Math.floor(Math.random() * neighbors.length)];
                            removeWalls(current, next);
                            next.visited = true;
                            current = next;
                        } else if (stack.length > 0) {
                            current = stack.pop();
                        } else {
                            openExtraPaths(0.2);
                            callback();
                            return;
                        }
                        stepsInBatch++;
                        if (neighbors.length === 0 && stack.length === 0) {
                            openExtraPaths(0.2);
                            callback();
                            return;
                        }
                    }
                    requestAnimationFrame(stepBatch);
                }
                requestAnimationFrame(stepBatch);
            }

            function findAnswerPath() {
                path = [];
                let visited = new Set();
                function dfs(x, y) {
                    if (x === COLS - 1 && y === ROWS - 1) {
                        path.push({ i: x, j: y });
                        return true;
                    }
                    visited.add(`${x},${y}`);
                    path.push({ i: x, j: y });
                    let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
                    for (let i = directions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [directions[i], directions[j]] = [directions[j], directions[i]];
                    }
                    for (let [dx, dy] of directions) {
                        let nx = x + dx;
                        let ny = y + dy;
                        if (nx >= 0 && ny >= 0 && nx < COLS && ny < ROWS && !visited.has(`${nx},${ny}`)) {
                            let currentCell = grid[index(x, y)];
                            if (
                                (dx == 1 && !currentCell.walls[1]) ||
                                (dx == -1 && !currentCell.walls[3]) ||
                                (dy == 1 && !currentCell.walls[2]) ||
                                (dy == -1 && !currentCell.walls[0])
                            ) {
                                if (dfs(nx, ny)) return true;
                            }
                        }
                    }
                    path.pop();
                    return false;
                }
                dfs(0, 0);
            }

            function placeLetters() {
                letters = [];
                answerLetterCoords.clear();
                totalAnswerLetters = 0;
                const answerChars = answer.split("");
                const N = answerChars.length;
                const availablePathCoords = path.slice(1, -1);
                const L = availablePathCoords.length;

                if (L < N) {
                    console.error(`ê²½ë¡œ ê¸¸ì´ ë¶€ì¡±! ì‚¬ìš© ê°€ëŠ¥ ê²½ë¡œ: ${L}, í•„ìš”í•œ ê¸€ì ìˆ˜: ${N}`);
                    return;
                }

                const occupiedIndices = new Set();
                let lastPlacedIndex = -1;

                for (let i = 0; i < N; i++) {
                    let targetIndex, offsetRange;
                    const searchStartIndex = lastPlacedIndex + 1;
                    if (i === N - 1) {
                        const endIndex = L - 1;
                        const startIndex = Math.max(searchStartIndex, L - Math.ceil(L * 0.15));
                        targetIndex = startIndex + Math.floor(Math.random() * Math.max(0, (endIndex - startIndex + 1)));
                        offsetRange = Math.floor(L / N * 0.3);
                    } else {
                        targetIndex = Math.max(searchStartIndex, Math.round(i * (L - 1) / (N - 1)));
                        offsetRange = Math.floor(L / N * 0.4);
                    }
                    const randomOffset = Math.floor(Math.random() * (offsetRange * 2 + 1)) - offsetRange;
                    let placementIndex = Math.max(searchStartIndex, Math.min(L - 1, targetIndex + randomOffset));
                    let foundIndex = -1;
                    for (let currentIdx = placementIndex; currentIdx < L; currentIdx++) {
                        if (!occupiedIndices.has(currentIdx)) {
                            foundIndex = currentIdx;
                            break;
                        }
                    }
                    if (foundIndex === -1) {
                        for (let currentIdx = placementIndex - 1; currentIdx >= searchStartIndex; currentIdx--) {
                            if (!occupiedIndices.has(currentIdx)) {
                                foundIndex = currentIdx;
                                break;
                            }
                        }
                    }
                    if (foundIndex !== -1) {
                        const p = availablePathCoords[foundIndex];
                        letters.push({ x: p.i, y: p.j, char: answerChars[i], isAnswer: true });
                        answerLetterCoords.add(`${p.i},${p.j}`);
                        occupiedIndices.add(foundIndex);
                        lastPlacedIndex = foundIndex;
                        totalAnswerLetters++;
                    } else {
                        let emergencyIndex = -1;
                        for (let tempIdx = searchStartIndex; tempIdx < L; tempIdx++) {
                            if (!occupiedIndices.has(tempIdx)) {
                                emergencyIndex = tempIdx;
                                break;
                            }
                        }
                        if (emergencyIndex !== -1) {
                            const p = availablePathCoords[emergencyIndex];
                            letters.push({ x: p.i, y: p.j, char: answerChars[i], isAnswer: true });
                            answerLetterCoords.add(`${p.i},${p.j}`);
                            occupiedIndices.add(emergencyIndex);
                            lastPlacedIndex = emergencyIndex;
                            totalAnswerLetters++;
                        } else {
                            console.error("!!! ê¸€ì ë¹„ìƒ ë°°ì¹˜ ì‹¤íŒ¨ !!!");
                        }
                    }
                }
                letters.push({ x: 0, y: 0, char: "ì¶œë°œ", isAnswer: false, isLabel: true });
                letters.push({ x: COLS - 1, y: ROWS - 1, char: "ë„ì°©", isAnswer: false, isLabel: true });
            }

            function placeDecoyLetters() {
                const occupiedCoords = new Set();
                letters.forEach(l => occupiedCoords.add(`${l.x},${l.y}`));
                const availableCells = [];
                for (let j = 0; j < ROWS; j++) {
                    for (let i = 0; i < COLS; i++) {
                        if (!occupiedCoords.has(`${i},${j}`)) {
                            availableCells.push({ x: i, y: j });
                        }
                    }
                }
                const numDecoys = Math.max(0, availableCells.length - answer.length * 2);
                for (let i = availableCells.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
                }
                const pathCoords = new Set(path.map(p => `${p.i},${p.j}`));
                let placedCount = 0;
                for (let k = 0; k < availableCells.length && placedCount < numDecoys; k++) {
                    const cell = availableCells[k];
                    if (pathCoords.has(`${cell.x},${cell.y}`)) continue;
                    const randomChar = answer[Math.floor(Math.random() * answer.length)];
                    letters.push({ x: cell.x, y: cell.y, char: randomChar, isAnswer: false, isDecoy: true });
                    placedCount++;
                }
            }

            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                for (let c of grid) {
                    let x = c.i * CELL;
                    let y = c.j * CELL;
                    ctx.strokeStyle = "rgb(8, 98, 158)";
                    ctx.lineWidth = 2;
                    if (c.walls[0]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + CELL, y); ctx.stroke(); }
                    if (c.walls[1]) { ctx.beginPath(); ctx.moveTo(x + CELL, y); ctx.lineTo(x + CELL, y + CELL); ctx.stroke(); }
                    if (c.walls[2]) { ctx.beginPath(); ctx.moveTo(x + CELL, y + CELL); ctx.lineTo(x, y + CELL); ctx.stroke(); }
                    if (c.walls[3]) { ctx.beginPath(); ctx.moveTo(x, y + CELL); ctx.lineTo(x, y); ctx.stroke(); }
                }
                if (showPath && path.length > 0) {
                    ctx.strokeStyle = "#00ffff";
                    ctx.lineWidth = 8;
                    ctx.beginPath();
                    ctx.moveTo(path[0].i * CELL + CELL / 2, path[0].j * CELL + CELL / 2);
                    path.forEach(p => ctx.lineTo(p.i * CELL + CELL / 2, p.j * CELL + CELL / 2));
                    ctx.stroke();
                }
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                for (const l of letters) {
                    const letterKey = `${l.x},${l.y}`;
                    ctx.fillStyle = l.isAnswer && visitedCells.has(letterKey) ? "red" : "#2f4f4f";
                    if (l.isLabel) {
                        ctx.fillStyle = "#c71585";
                    }
                    const fontSize = l.isLabel ? CELL / 4 : CELL / 3;
                    ctx.font = `${fontSize}px 'Gothic A1', sans-serif`;
                    ctx.fillText(l.char, l.x * CELL + CELL / 2, l.y * CELL + CELL / 2);
                }

                if (isGameActive) {
                    ctx.fillStyle = "rgb(8, 98, 158, 0.65)";

                    ctx.fillRect(player.x * CELL + CELL / 4, player.y * CELL + CELL / 4, CELL / 2, CELL / 2);
                }
                document.getElementById("scoreDisplay").innerText = `ğŸ† ì ìˆ˜: ${score}`;
                document.getElementById("timeDisplay").innerText = `â³ ë‚¨ì€ ì‹œê°„: ${remainingTime}ì´ˆ`;
            }

            function move(dx, dy) {
                if (!isGameActive) return;
                let nextX = player.x + dx;
                let nextY = player.y + dy;
                if (nextX < 0 || nextY < 0 || nextX >= COLS || nextY >= ROWS) return;
                let currentCell = grid[index(player.x, player.y)];
                if (!currentCell) return;
                let moved = false;
                if (dx === 1 && !currentCell.walls[1]) { player.x++; moved = true; }
                if (dx === -1 && !currentCell.walls[3]) { player.x--; moved = true; }
                if (dy === 1 && !currentCell.walls[2]) { player.y++; moved = true; }
                if (dy === -1 && !currentCell.walls[0]) { player.y--; moved = true; }
                if (moved) {
                    const nextPosKey = `${nextX},${nextY}`;
                    if (answerLetterCoords.has(nextPosKey) && !collectedLetterCoords.has(nextPosKey)) {
                        collectedLetterCoords.add(nextPosKey);
                        score += 10;
                    }
                    moveStack.push({ x: player.x, y: player.y });
                    visitedCells.add(nextPosKey);
                    draw();
                    if (nextX === COLS - 1 && nextY === ROWS - 1) {
                        if (collectedLetterCoords.size === totalAnswerLetters) {
                            endGame(`í´ë¦¬ì–´! ğŸ‰ ì ìˆ˜: ${score + 10}, ë‚¨ì€ ì‹œê°„: ${remainingTime} ì´ˆ`);
                            score += 10; // ë„ì°© ë³´ë„ˆìŠ¤
                        } else {
                            endGame(`ë„ì°©í–ˆì§€ë§Œ ëª¨ë“  ê¸€ìë¥¼ ëª¨ìœ¼ì§€ ëª»í–ˆì–´ìš”! ğŸ˜¥`);
                        }
                    }
                }
            }

            function undoMove() {
                if (!isGameActive || moveStack.length <= 1) return;
                visitedCells.delete(`${player.x},${player.y}`);
                moveStack.pop();
                let prev = moveStack[moveStack.length - 1];
                player.x = prev.x;
                player.y = prev.y;
                draw();
            }

            function startTimer() {
                if (interval) clearInterval(interval);
                document.getElementById("timeDisplay").innerText = `â³ ë‚¨ì€ ì‹œê°„: ${remainingTime}ì´ˆ`;
                interval = setInterval(() => {
                    remainingTime--;
                    if (remainingTime <= 0) {
                        clearInterval(interval);
                        interval = null;
                        endGame("ì‹œê°„ ì´ˆê³¼! â³ ê²Œì„ ì˜¤ë²„!");
                    }
                    document.getElementById("timeDisplay").innerText = `â³ ë‚¨ì€ ì‹œê°„: ${remainingTime}ì´ˆ`;
                }, 1000);
            }

            function endGame(message) {
                isGameActive = false;
                if (interval) {
                    clearInterval(interval);
                    interval = null;
                }
                document.getElementById("resultMsg").innerText = message;
                document.getElementById("stopGameBtn").disabled = true;
                document.getElementById("showPathBtn").disabled = false;
                document.getElementById("hidePathBtn").disabled = false;
                draw();
            }

            function startGame() {

                const length = answersList.length;
                let levelTime = 60;
                for (let i = 0; i < length; i++) {
                    LEVEL_TIME_LIMITS.push(levelTime)
                    levelTime += 30;
                }
                const loadingOverlay = document.getElementById("loadingOverlay");
                const startGameBtn = document.getElementById("startGameBtn");
                const stopGameBtn = document.getElementById("stopGameBtn");
                const showPathBtn = document.getElementById("showPathBtn");
                const hidePathBtn = document.getElementById("hidePathBtn");
                const levelSelect = document.getElementById("levelSelect");

                if (!loadingOverlay.classList.contains("hidden")) return;

                loadingOverlay.classList.remove("hidden");
                startGameBtn.disabled = true;
                stopGameBtn.disabled = true;
                showPathBtn.disabled = true;
                hidePathBtn.disabled = true;
                levelSelect.disabled = true;

                const level = parseInt(levelSelect.value);
                answer = answersList[level - 1];
                remainingTime = LEVEL_TIME_LIMITS[level - 1];
                COLS = Math.floor(canvas.width / 40);
                ROWS = Math.floor(canvas.height / 40);
                CELL = 40;
                player = { x: 0, y: 0 };
                moveStack = [{ x: 0, y: 0 }];
                visitedCells = new Set(["0,0"]);
                showPath = false;
                score = 0;
                collectedLetterCoords.clear();
                answerLetterCoords.clear();
                totalAnswerLetters = 0;
                isGameActive = true;
                document.getElementById("resultMsg").innerText = "";

                generateMaze(() => {
                    findAnswerPath();
                    placeLetters();
                    placeDecoyLetters();
                    draw();
                    startTimer();
                    setupTouchControls();
                    loadingOverlay.classList.add("hidden");
                    startGameBtn.disabled = false;
                    stopGameBtn.disabled = false;
                    showPathBtn.disabled = false;
                    hidePathBtn.disabled = false;
                    levelSelect.disabled = false;
                });
            }

            function stopGame() {
                endGame("ê²Œì„ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.");
            }

            function setupTouchControls() {
                let startX, startY;
                canvas.addEventListener("touchstart", e => {
                    if (!isGameActive) return;
                    startX = e.touches[0].clientX;
                    startY = e.touches[0].clientY;
                });
                canvas.addEventListener("touchend", e => {
                    if (!isGameActive) return;
                    let dx = e.changedTouches[0].clientX - startX;
                    let dy = e.changedTouches[0].clientY - startY;
                    let threshold = 30;
                    if (Math.abs(dx) > Math.abs(dy)) {
                        if (dx > threshold) move(1, 0);
                        else if (dx < -threshold) move(-1, 0);
                    } else {
                        if (dy > threshold) move(0, 1);
                        else if (dy < -threshold) move(0, -1);
                    }
                });
            }

            document.addEventListener("keydown", function (event) {
                if (!isGameActive) return;
                if (event.key === "ArrowUp") { move(0, -1); event.preventDefault(); }
                if (event.key === "ArrowDown") { move(0, 1); event.preventDefault(); }
                if (event.key === "ArrowLeft") { move(-1, 0); event.preventDefault(); }
                if (event.key === "ArrowRight") { move(1, 0); event.preventDefault(); }
                if (event.key === "Backspace") { undoMove(); event.preventDefault(); }
            });

            function showAnswerPath() {
                if (!grid.length) return;
                showPath = true;
                draw();
            }

            function hideAnswerPath() {
                showPath = false;
                draw();
            }
        </script>
    </body>

</html>
