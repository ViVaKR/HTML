<!DOCTYPE html>
<html lang="ko">

  <head>
    <meta charset="UTF-8">
    <title>ë¯¸ë¡œ ê²Œì„ (í•™ìŠµìš© ì£¼ì„ í¬í•¨)</title>

    <style>
      /* ìŠ¤íƒ€ì¼ */
      body {
        font-family: sans-serif;
        text-align: center;
        background: #f9f9f9;
      }

      /* ìº”ë²„ìŠ¤ ìŠ¤íƒ€ì¼ (ë¯¸ë¡œê°€ ê·¸ë ¤ì§ˆ ì˜ì—­) */
      canvas {
        border: 2px solid #333;
        background: #fff;
        margin-top: 10px;
        touch-action: none;
        /* ëª¨ë°”ì¼ í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€ */
      }

      /* ì…ë ¥ ìš”ì†Œ, ë²„íŠ¼, ì„ íƒ ë©”ë‰´ ìŠ¤íƒ€ì¼ */
      button {
        padding: 10px 20px;
        margin: 10px;
        font-size: 1rem;
        border-radius: 10px;
        border: none;
        color: white;
        cursor: pointer;
      }

      button:hover {
        background-color: #ff0000;
      }

      select {
        -webkit-appearance: none;
        -moz-appearance: none;
        font-size: 1rem;
        margin: 0 0.5rem;
        appearance: none;
        padding: 10px;
        width: 150px;
        cursor: pointer;
      }

      /* íƒ€ì´ë¨¸ í…ìŠ¤íŠ¸ ìŠ¤íƒ€ì¼ */
      #timer {
        font-weight: bold;
        color: darkred;
      }

      /* í”ë“¤ë¦¼ ì• ë‹ˆë©”ì´ì…˜ (ì˜¤ë‹µ ì‹œ) */
      .shake {
        animation: shake 0.3s;
      }

      /* --- ë¡œë”© ì¸ë””ì¼€ì´í„° ìŠ¤íƒ€ì¼ ì¶”ê°€ --- */
      #loadingOverlay {
        position: absolute;
        /* ìº”ë²„ìŠ¤ ìœ„ì— ìœ„ì¹˜ */
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(255, 255, 255, 0.7);
        /* ë°˜íˆ¬ëª… í°ìƒ‰ ë°°ê²½ */
        z-index: 10;
        /* ë‹¤ë¥¸ ìš”ì†Œë“¤ ìœ„ì— í‘œì‹œ */
        display: flex;
        justify-content: center;
        align-items: center;
      }

      .loader {
        border: 8px solid #f3f3f3;
        /* Light grey */
        border-top: 8px solid #3498db;
        /* Blue */
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }

        100% {
          transform: rotate(360deg);
        }
      }

      .hidden {
        display: none !important;
        /* í™•ì‹¤í•˜ê²Œ ìˆ¨ê¸°ê¸° */
      }

      @keyframes shake {
        0% {
          transform: translate(2px, 2px);
        }

        25% {
          transform: translate(-2px, -2px);
        }

        50% {
          transform: translate(2px, -2px);
        }

        75% {
          transform: translate(-2px, 2px);
        }

        100% {
          transform: translate(0, 0);
        }
      }
    </style>

  </head>

  <body>
    <div style="overflow: hidden;">
      <h1>ğŸ® ì •ë‹µ ê¸°ë°˜ ë¯¸ë¡œ ê²Œì„</h1>

      <div style="display: flex; gap: 1rem; align-items: center; justify-content:center; width: 100vw;">
        <!-- ê²Œì„ ë‚œì´ë„ ì„ íƒ ë“œë¡­ë‹¤ìš´ -->
        <div style="width: 300px; display:flex; align-items: center; justify-content: center;">
          <label style="font-size: 1.3rem; color: #454545;">ë‚œì´ë„ </label>
          <select id="levelSelect"></select>
        </div>
        <!-- ê²Œì„ ì»¨íŠ¸ë¡¤ ë²„íŠ¼ -->
        <button onclick="startGame()" id="startGameBtn">ê²Œì„ ì‹œì‘</button>
        <button onclick="stopTimer()" id="startGameBtn">ê²Œì„ ì¤‘ì§€</button>
        <button onclick="showAnswerPath()" id="showPathBtn">ì •ë‹µ í™•ì¸</button>
        <button onclick="hideAnswerPath()" id="hidePathBtn">ì •ë‹µ ìˆ¨ê¸°ê¸°</button>
      </div>
      <!-- ê²½ê³¼ ì‹œê°„ í‘œì‹œ ì˜ì—­ -->
      <p id="timer">â± ê²½ê³¼ ì‹œê°„: 0ì´ˆ</p>

      <!-- HTML Body ì¤‘ê°„, ì˜ˆë¥¼ ë“¤ì–´ ìº”ë²„ìŠ¤ ìœ„ì— ë°°ì¹˜ -->
      <div id="loadingOverlay" class="hidden">
        <div class="loader"></div>
      </div>

      <!-- ë¯¸ë¡œê°€ ê·¸ë ¤ì§ˆ ìº”ë²„ìŠ¤ ìš”ì†Œ -->
      <canvas id="maze" width="1000"
              height="760"
              style="border: solid 5px gray;
              position: relative">
      </canvas>

      <!-- ì •ë‹µ ì…ë ¥ ë° ì œì¶œ -->
      <div style="display: flex; flex-direction: column; gap: 10px; padding: 1rem;">
        <input id="answerInput" placeholder="ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”"
               style="width: auto; padding: 20px; border: solid 1px gray;border-radius:5px;" />
        <button onclick="checkAnswer()">ì •ë‹µ ì œì¶œ</button>
      </div>

      <!-- ê²°ê³¼ ë©”ì‹œì§€ í‘œì‹œ ì˜ì—­ -->
      <p id="resultMsg"></p>
    </div>


    <script>
      // --- ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ ---

      // ê° ë ˆë²¨ë³„ ì •ë‹µ ë¬¸ì¥ ë°°ì—´
      const answersList = [
        "í•œìš©ìš´ì€ ì˜¤ëŠ˜ë„ ë¯¼ì¡±ì˜ ë…ë¦½ì„ ìœ„í•´ì„œ ë…¸ë ¥í•˜ëŠ” ì¤‘ì´ë‹¤",
        "ì—°í¬ ì „ë¬¸ì¡¸ì—…ë°˜ì— ì¬í•™ ì¤‘ì¼ ë•Œ ì§€ì€ ê²ƒìœ¼ë¡œ ì•Œë ¤ì ¸ ìˆëŠ” ì‹­ìê°€ëŠ” ìˆœì ˆ ì •ì‹ ê³¼ ì†ì£„ì–‘ ì˜ì‹ì„ ë°”íƒ•ìœ¼ë¡œ í•œ ìê¸°í¬ìƒì˜ ì´ë…ì„ í‘œì¶œí•˜ê³  ìˆë‹¤",
        "4ì—°ì—ì„œëŠ” ê·¸ëŸ¬í•œ ê°ˆë“±ì„ ê²ªì€ í™”ìê°€ ì²¨íƒ‘ì— ì˜¤ë¥¼ ìˆ˜ ì—†ë‹¤ë©´ ì°¨ë¼ë¦¬ ê·¸ë¦¬ìŠ¤ë„ì˜ í¬ìƒì„ ë³¸ë°›ì•„ ê³ ë‚œ ì†ì—ì„œ ì‹ ìŒí•˜ê³  ìˆëŠ” ë¯¼ì¡±ì„ ìœ„í•´ ì†ì£„ì–‘ì´ ë˜ê³  ì‹¶ë‹¤",
        "5ì—°ì€ ìê¸°í¬ìƒì´ë‚˜ ì†ì£„ì–‘ ì˜ì‹ì´ ì‘ì¶•ë˜ì–´ ë‚˜íƒ€ë‚œ ë¶€ë¶„ìœ¼ë¡œ ì£¼ì œì—°ì— í•´ë‹¹í•œë‹¤",
        "1ì—°ì—ì„œëŠ” ìƒì‹¤ì˜ ìƒí™©ê³¼ ê·¸ ìƒí™©ì—ì„œ ë¬´ì˜ì‹ì ìœ¼ë¡œ ë‚˜ì˜¨ í–‰ë™ì„ í˜•ìƒí™”í•˜ê³  ìˆëŠ”ë° í™”ìëŠ” ë¬´ì–¸ê°€ë¥¼ ìƒì–´ë²„ë ¸ì§€ë§Œ ê·¸ê²ƒì´ ë¬´ì—‡ì¸ì§€ ë˜í•œ ëª¨ë¥¸ë‹¤",
        "3ì—°ì—ì„œëŠ” ëŒë‹´ ì•ˆìª½ìœ¼ë¡œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ” í†µë¡œë¥¼ ì œì‹œí•˜ê³  ìˆì§€ë§Œ ê·¸ê²ƒì´ ê¸´ ê·¸ë¦¼ìë¥¼ ë“œë¦¬ìš´ ì±„ ì‡ ë¬¸ìœ¼ë¡œ êµ³ê²Œ ë‹«í˜€ ìˆë‹¤ê³  í•¨ìœ¼ë¡œì¨ ì•”ì‹œí•œë‹¤",
        "4ì—°ì—ì„œëŠ” ì‹œê°„ ì†ì—ì„œ ì‹œê°„ê³¼ í•¨ê»˜ ì‚´ì•„ê°€ëŠ” ì‚¶ì˜ ê³¼ì •ìœ¼ë¡œì„œì˜ ê¸¸ì˜ ì˜ë¯¸ë¥¼ í˜•ìƒí™”í•˜ê³  ìˆëŠ”ë° ê¸¸ì˜ ì§„í–‰ì€ ê³§ ì‹œê°„ì˜ ê²½ê³¼ë¥¼ ì˜ë¯¸í•œë‹¤",
        "5ì—°ì—ì„œëŠ” ë¶€ë„ëŸ¬ì›€ì„ í†µí•œ ìì•„ì˜ ê°ˆë“±ê³¼ ê°ì„±ì„ í˜•ìƒí™”í•˜ê³  ìˆëŠ”ë° ì´ìƒì  ìì•„ë¥¼ íšŒë³µí•  ìˆ˜ ì—†ìŒì„ ê¹¨ë‹¬ì€ í™”ìê°€ ì³ë‹¤ë³¸ í•˜ëŠ˜ì€ í˜„ì‹¤ì ì´ë‹¤",
        "7ì—°ì—ì„œëŠ” ì‚¶ì— ëŒ€í•œ í™”ìì˜ íƒœë„ë¥¼ í¬ê´„ì ìœ¼ë¡œ ì œì‹œí•˜ê³  ë¶ˆëª¨ì˜ ê¸¸ì„ ê±·ëŠ” ê²ƒì€ ë‹´ ì €ìª½ì— ì¡´ì¬í•´ ìˆëŠ” ìƒì–´ë²„ë¦° ìì•„ë¥¼ ì°¾ê¸° ìœ„í•¨ì´ë‹¤"
      ];

      let answer = ""; // í˜„ì¬ ë ˆë²¨ì˜ ì •ë‹µ ë¬¸ì¥
      let COLS, ROWS, CELL; // ë¯¸ë¡œì˜ ì—´(ì¹¸ ìˆ˜), í–‰(ì¹¸ ìˆ˜), ê° ì…€ì˜ í¬ê¸°
      const canvas = document.getElementById("maze"); // HTMLì˜ canvas ìš”ì†Œë¥¼ ê°€ì ¸ì˜´
      const ctx = canvas.getContext("2d"); // ìº”ë²„ìŠ¤ì— ê·¸ë¦¼ì„ ê·¸ë¦¬ê¸° ìœ„í•œ 2D ë Œë”ë§ ì»¨í…ìŠ¤íŠ¸
      let player = { x: 0, y: 0 }; // í”Œë ˆì´ì–´ì˜ í˜„ì¬ ìœ„ì¹˜ (x, y ì¢Œí‘œ)
      let grid = []; // ë¯¸ë¡œì˜ ëª¨ë“  ì…€(ì¹¸) ì •ë³´ë¥¼ ë‹´ëŠ” ë°°ì—´ (Cell ê°ì²´ ì €ì¥)
      let path = []; // ë¯¸ë¡œì˜ ì •ë‹µ ê²½ë¡œ (ì¢Œí‘œ ê°ì²´ {i, j} ì €ì¥)
      let letters = []; // ë¯¸ë¡œì— ë°°ì¹˜ë  ê¸€ì ì •ë³´ ë°°ì—´ ({x, y, char, isAnswer, isLabel})
      let moveStack = []; // í”Œë ˆì´ì–´ì˜ ì´ë™ ê²½ë¡œë¥¼ ê¸°ë¡í•˜ëŠ” ìŠ¤íƒ (ë˜ëŒì•„ê°€ê¸° ê¸°ëŠ¥ì— ì‚¬ìš©)
      let showPath = false; // ì •ë‹µ ê²½ë¡œ í‘œì‹œ ì—¬ë¶€ í”Œë˜ê·¸
      let timerStart = 0; // ê²Œì„ ì‹œì‘ ì‹œê°„ (íƒ€ì´ë¨¸ ê³„ì‚°ìš©)
      let interval; // íƒ€ì´ë¨¸ ë°˜ë³µ ì‹¤í–‰ ID (clearIntervalì— ì‚¬ìš©)
      let visitedCells = new Set(); // í”Œë ˆì´ì–´ê°€ ë°©ë¬¸í•œ ì…€ì˜ ì¢Œí‘œ ë¬¸ìì—´("x,y")ì„ ì €ì¥í•˜ëŠ” Set (ê¸€ì ìƒ‰ ë³€ê²½ ë° ì¤‘ë³µ ë°©ì§€)

      // --- ì´ˆê¸° ì„¤ì • í•¨ìˆ˜ ---

      /**
       * ë‚œì´ë„ ì„ íƒ ë“œë¡­ë‹¤ìš´ ë©”ë‰´ë¥¼ ìƒì„±í•˜ê³  ì´ˆê¸°í™”í•˜ëŠ” í•¨ìˆ˜.
       * 1ë¶€í„° 9ê¹Œì§€ì˜ ë ˆë²¨ ì˜µì…˜ì„ ìƒì„±í•˜ì—¬ <select> ìš”ì†Œì— ì¶”ê°€.
       */
      function setupLevels() {
        const select = document.getElementById("levelSelect");
        for (let i = 1; i <= 9; i++) {
          const opt = document.createElement("option"); // ìƒˆë¡œìš´ <option> ìš”ì†Œ ìƒì„±
          opt.value = i; // ì˜µì…˜ ê°’ ì„¤ì • (ë ˆë²¨ ë²ˆí˜¸)
          opt.innerText = `${i}ë‹¨ê³„`; // ì˜µì…˜ í…ìŠ¤íŠ¸ ì„¤ì •
          select.appendChild(opt); // <select>ì— ì˜µì…˜ ì¶”ê°€
        }
        select.value = 1; // ê¸°ë³¸ ì„ íƒê°’ì„ 1ë‹¨ê³„ë¡œ ì„¤ì •
      }

      // HTML ë¬¸ì„œ ë¡œë”©ì´ ì™„ë£Œë˜ë©´ setupLevels í•¨ìˆ˜ë¥¼ ì‹¤í–‰ (ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ)
      document.addEventListener("DOMContentLoaded", setupLevels);

      // --- ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ---

      /**
       * 2ì°¨ì› ì¢Œí‘œ (i, j)ë¥¼ 1ì°¨ì› ë°°ì—´ gridì˜ ì¸ë±ìŠ¤ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜.
       * @param {number} i - ì—´(ê°€ë¡œ) ì¸ë±ìŠ¤
       * @param {number} j - í–‰(ì„¸ë¡œ) ì¸ë±ìŠ¤
       * @returns {number} 1ì°¨ì› ë°°ì—´ ì¸ë±ìŠ¤. ìœ íš¨í•˜ì§€ ì•Šì€ ì¢Œí‘œë©´ -1 ë°˜í™˜.
       */
      function index(i, j) {
        if (i < 0 || j < 0 || i >= COLS || j >= ROWS) return -1; // ë¯¸ë¡œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚˜ë©´ -1 ë°˜í™˜
        return i + j * COLS; // 1ì°¨ì› ì¸ë±ìŠ¤ ê³„ì‚° (ê°€ë¡œ ìœ„ì¹˜ + ì„¸ë¡œ ìœ„ì¹˜ * ê°€ë¡œ ì¹¸ ìˆ˜)
      }

      // --- ë¯¸ë¡œ ìƒì„± ê´€ë ¨ í•¨ìˆ˜ ---

      /**
       * ë¯¸ë¡œì˜ ê° ì…€(ì¹¸)ì„ ë‚˜íƒ€ë‚´ëŠ” ê°ì²´ ìƒì„±ì í•¨ìˆ˜.
       * @param {number} i - ì…€ì˜ ì—´(ê°€ë¡œ) ì¸ë±ìŠ¤
       * @param {number} j - ì…€ì˜ í–‰(ì„¸ë¡œ) ì¸ë±ìŠ¤
       */
      function Cell(i, j) {
        this.i = i; // ì—´ ì¸ë±ìŠ¤
        this.j = j; // í–‰ ì¸ë±ìŠ¤
        // ê° ì…€ì˜ ë²½ ìƒíƒœ [ìƒ, ìš°, í•˜, ì¢Œ] (true: ë²½ ìˆìŒ, false: ë²½ ì—†ìŒ)
        this.walls = [true, true, true, true];
        this.visited = false; // ë¯¸ë¡œ ìƒì„± ì‹œ ë°©ë¬¸ ì—¬ë¶€ í”Œë˜ê·¸
      }

      /**
       * ë‘ ì¸ì ‘í•œ ì…€ ì‚¬ì´ì˜ ë²½ì„ ì œê±°í•˜ëŠ” í•¨ìˆ˜.
       * @param {Cell} a - ì²« ë²ˆì§¸ ì…€ ê°ì²´
       * @param {Cell} b - ë‘ ë²ˆì§¸ ì…€ ê°ì²´ (aì™€ ì¸ì ‘í•´ì•¼ í•¨)
       */
      function removeWalls(a, b) {
        let dx = a.i - b.i; // xì¶• ë°©í–¥ ì°¨ì´
        let dy = a.j - b.j; // yì¶• ë°©í–¥ ì°¨ì´

        // xì¶•ìœ¼ë¡œ 1 ì°¨ì´ (aê°€ bì˜ ì˜¤ë¥¸ìª½) -> aì˜ ì™¼ìª½ ë²½, bì˜ ì˜¤ë¥¸ìª½ ë²½ ì œê±°
        if (dx == 1) { a.walls[3] = false; b.walls[1] = false; }
        // xì¶•ìœ¼ë¡œ -1 ì°¨ì´ (aê°€ bì˜ ì™¼ìª½) -> aì˜ ì˜¤ë¥¸ìª½ ë²½, bì˜ ì™¼ìª½ ë²½ ì œê±°
        if (dx == -1) { a.walls[1] = false; b.walls[3] = false; }
        // yì¶•ìœ¼ë¡œ 1 ì°¨ì´ (aê°€ bì˜ ì•„ë˜ìª½) -> aì˜ ìœ„ìª½ ë²½, bì˜ ì•„ë˜ìª½ ë²½ ì œê±°
        if (dy == 1) { a.walls[0] = false; b.walls[2] = false; }
        // yì¶•ìœ¼ë¡œ -1 ì°¨ì´ (aê°€ bì˜ ìœ„ìª½) -> aì˜ ì•„ë˜ìª½ ë²½, bì˜ ìœ„ìª½ ë²½ ì œê±°
        if (dy == -1) { a.walls[2] = false; b.walls[0] = false; }
      }

      // í—·ê°ˆë¦¬ê²Œ ë²½ì„ í—ˆëŠ” ë¹„ìœ¨.. ë†’ì„ ìˆ˜ë¡ ë²½ì„ ë§ì•„ í—ˆë­„
      function openExtraPaths(probability = 0.2) {
        for (let c of grid) {
          // ê° ì…€ë§ˆë‹¤ ëœë¤ í™•ë¥ ë¡œ
          if (Math.random() < probability) {
            const neighbors = [];

            // ê° ë°©í–¥ë³„ë¡œ ì´ì›ƒ ì…€ì„ ì¡°ì‚¬
            let top = grid[index(c.i, c.j - 1)];
            let right = grid[index(c.i + 1, c.j)];
            let bottom = grid[index(c.i, c.j + 1)];
            let left = grid[index(c.i - 1, c.j)];

            if (top && c.walls[0]) neighbors.push({ dir: 0, cell: top });
            if (right && c.walls[1]) neighbors.push({ dir: 1, cell: right });
            if (bottom && c.walls[2]) neighbors.push({ dir: 2, cell: bottom });
            if (left && c.walls[3]) neighbors.push({ dir: 3, cell: left });

            if (neighbors.length > 0) {
              const { dir, cell: neighbor } = neighbors[Math.floor(Math.random() * neighbors.length)];

              // ë²½ ì œê±°
              c.walls[dir] = false;
              neighbor.walls[(dir + 2) % 4] = false; // ë°˜ëŒ€í¸ ë²½ë„ ì œê±°
            }
          }
        }
      }

      /**
       * ë¯¸ë¡œë¥¼ ìƒì„±í•˜ëŠ” í•¨ìˆ˜ (Depth First Search - Recursive Backtracker ì•Œê³ ë¦¬ì¦˜ ì‚¬ìš©).
       * ë¯¸ë¡œ ìƒì„±ì´ ì™„ë£Œë˜ë©´ ì½œë°± í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
       * @param {function} callback - ë¯¸ë¡œ ìƒì„±ì´ ì™„ë£Œëœ í›„ ì‹¤í–‰ë  í•¨ìˆ˜
       */
      function generateMazeBacup(callback) {
        // 1. ê·¸ë¦¬ë“œ ì´ˆê¸°í™”: ëª¨ë“  ì…€ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ grid ë°°ì—´ì— ì €ì¥
        grid = [];
        for (let j = 0; j < ROWS; j++) {
          for (let i = 0; i < COLS; i++) {
            grid.push(new Cell(i, j));
          }
        }

        // 2. ì‹œì‘ ì…€ ì„¤ì • ë° ìŠ¤íƒ ì´ˆê¸°í™”
        let current = grid[0]; // (0, 0) ì…€ì—ì„œ ì‹œì‘
        current.visited = true; // ì‹œì‘ ì…€ ë°©ë¬¸ ì²˜ë¦¬
        let stack = []; // ë˜ëŒì•„ê°ˆ ê²½ë¡œë¥¼ ì €ì¥í•  ìŠ¤íƒ

        const batchSize = 100;

        // 3. DFS ìŠ¤í… í•¨ìˆ˜ (ì¬ê·€, ë°˜ë³µí˜¸ì¶œ)
        function step() {

          // í˜„ì¬ ì…€ì—ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì´ì›ƒ ì…€ ì°¾ê¸°
          let neighbors = [];
          let top = grid[index(current.i, current.j - 1)];
          let right = grid[index(current.i + 1, current.j)];
          let bottom = grid[index(current.i, current.j + 1)];
          let left = grid[index(current.i - 1, current.j)];
          // ìœ íš¨í•˜ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ì´ì›ƒë§Œ neighbors ë°°ì—´ì— ì¶”ê°€
          [top, right, bottom, left].forEach(n => { if (n && !n.visited) neighbors.push(n); });

          if (neighbors.length > 0) { // ë°©ë¬¸í•  ì´ì›ƒì´ ìˆìœ¼ë©´
            stack.push(current); // í˜„ì¬ ì…€ì„ ìŠ¤íƒì— push (ë‚˜ì¤‘ì— ë˜ëŒì•„ì˜¬ ìˆ˜ ìˆë„ë¡)
            // ì´ì›ƒ ì¤‘ í•˜ë‚˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì„ íƒ
            let next = neighbors[Math.floor(Math.random() * neighbors.length)];
            removeWalls(current, next); // í˜„ì¬ ì…€ê³¼ ë‹¤ìŒ ì…€ ì‚¬ì´ì˜ ë²½ ì œê±°
            next.visited = true; // ë‹¤ìŒ ì…€ ë°©ë¬¸ ì²˜ë¦¬
            current = next; // í˜„ì¬ ì…€ì„ ë‹¤ìŒ ì…€ë¡œ ì´ë™
            // ë¹„ë™ê¸° ì²˜ë¦¬: ë¸Œë¼ìš°ì € ë Œë”ë§ ì‹œê°„ì„ í™•ë³´í•˜ê³  ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
            setTimeout(step, 0); // ë‹¤ìŒ ìŠ¤í…ì„ ì ì‹œ í›„ì— ì‹¤í–‰
          } else if (stack.length > 0) { // ë°©ë¬¸í•  ì´ì›ƒì€ ì—†ê³ , ìŠ¤íƒì— ë˜ëŒì•„ê°ˆ ê²½ë¡œê°€ ìˆìœ¼ë©´
            current = stack.pop(); // ìŠ¤íƒì—ì„œ ì´ì „ ì…€ì„ êº¼ë‚´ì™€ í˜„ì¬ ì…€ë¡œ ì„¤ì • (ë§‰ë‹¤ë¥¸ ê¸¸ì—ì„œ ë˜ëŒì•„ê°)
            setTimeout(step, 0); // ë‹¤ìŒ ìŠ¤í… ì‹¤í–‰
          } else { // ë” ì´ìƒ ê°ˆ ê³³ë„ ì—†ê³  ìŠ¤íƒë„ ë¹„ì—ˆìœ¼ë©´ ë¯¸ë¡œ ìƒì„± ì™„ë£Œ
            openExtraPaths(); // í—·ê°ˆë¦¬ê²Œ í•˜ëŠ” ë¶€ë¶„
            callback(); // ì™„ë£Œ í›„ ì½œë°± í•¨ìˆ˜ ì‹¤í–‰ (ì˜ˆ: findAnswerPath, draw ë“± í˜¸ì¶œ)
          }
        }
        step(); // ë¯¸ë¡œ ìƒì„± ì‹œì‘
      }

      function generateMaze(callback) {
        // 1. ê·¸ë¦¬ë“œ ì´ˆê¸°í™”: ëª¨ë“  ì…€ ê°ì²´ë¥¼ ìƒì„±í•˜ì—¬ grid ë°°ì—´ì— ì €ì¥
        grid = [];
        for (let j = 0; j < ROWS; j++) {
          for (let i = 0; i < COLS; i++) {
            grid.push(new Cell(i, j));
          }
        }

        // 2. ì‹œì‘ ì…€ ì„¤ì • ë° ìŠ¤íƒ ì´ˆê¸°í™”
        let current = grid[0]; // (0, 0) ì…€ì—ì„œ ì‹œì‘
        current.visited = true; // ì‹œì‘ ì…€ ë°©ë¬¸ ì²˜ë¦¬
        let stack = []; // ë˜ëŒì•„ê°ˆ ê²½ë¡œë¥¼ ì €ì¥í•  ìŠ¤íƒ

        const batchSize = 100;

        // 3. DFS ìŠ¤í… í•¨ìˆ˜ (ì¬ê·€, ë°˜ë³µí˜¸ì¶œ)
        function stepBatch() {
          let stepsInBatch = 0;

          while (stepsInBatch < batchSize) {
            // í˜„ì¬ ì…€ì—ì„œ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì´ì›ƒ ì…€ ì°¾ê¸°
            let neighbors = [];

            let top = grid[index(current.i, current.j - 1)];
            let right = grid[index(current.i + 1, current.j)];
            let bottom = grid[index(current.i, current.j + 1)];
            let left = grid[index(current.i - 1, current.j)];
            // ìœ íš¨í•˜ê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ì´ì›ƒë§Œ neighbors ë°°ì—´ì— ì¶”ê°€
            [top, right, bottom, left].forEach(n => { if (n && !n.visited) neighbors.push(n); });




            if (neighbors.length > 0) { // ë°©ë¬¸í•  ì´ì›ƒì´ ìˆìœ¼ë©´
              stack.push(current); // í˜„ì¬ ì…€ì„ ìŠ¤íƒì— push (ë‚˜ì¤‘ì— ë˜ëŒì•„ì˜¬ ìˆ˜ ìˆë„ë¡)
              // ì´ì›ƒ ì¤‘ í•˜ë‚˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì„ íƒ
              let next = neighbors[Math.floor(Math.random() * neighbors.length)];
              removeWalls(current, next); // í˜„ì¬ ì…€ê³¼ ë‹¤ìŒ ì…€ ì‚¬ì´ì˜ ë²½ ì œê±°
              next.visited = true; // ë‹¤ìŒ ì…€ ë°©ë¬¸ ì²˜ë¦¬
              current = next; // í˜„ì¬ ì…€ì„ ë‹¤ìŒ ì…€ë¡œ ì´ë™
              // ë¹„ë™ê¸° ì²˜ë¦¬: ë¸Œë¼ìš°ì € ë Œë”ë§ ì‹œê°„ì„ í™•ë³´í•˜ê³  ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš° ë°©ì§€
            } else if (stack.length > 0) { // ë°©ë¬¸í•  ì´ì›ƒì€ ì—†ê³ , ìŠ¤íƒì— ë˜ëŒì•„ê°ˆ ê²½ë¡œê°€ ìˆìœ¼ë©´
              current = stack.pop(); // ìŠ¤íƒì—ì„œ ì´ì „ ì…€ì„ êº¼ë‚´ì™€ í˜„ì¬ ì…€ë¡œ ì„¤ì • (ë§‰ë‹¤ë¥¸ ê¸¸ì—ì„œ ë˜ëŒì•„ê°)
            } else { // ë” ì´ìƒ ê°ˆ ê³³ë„ ì—†ê³  ìŠ¤íƒë„ ë¹„ì—ˆìœ¼ë©´ ë¯¸ë¡œ ìƒì„± ì™„ë£Œ
              // --- ìƒì„± ì™„ë£Œ ---
              openExtraPaths(); // í—·ê°ˆë¦¬ê²Œ í•˜ëŠ” ë¶€ë¶„
              callback(); // ì™„ë£Œ í›„ ì½œë°± í•¨ìˆ˜ ì‹¤í–‰ (ì˜ˆ: findAnswerPath, draw ë“± í˜¸ì¶œ)
              return;
            }

            //
            stepsInBatch++
            // ìŠ¤íƒì´ ë¹„ê³  ì´ì›ƒë„ ì—†ìœ¼ë©´ ë£¨í”„ ê°•ì œ ì¢…ë£Œ (ìƒì„± ì™„ë£Œ)
            if (neighbors.length === 0 && stack.length === 0) {
              openExtraPaths();
              callback();
              return;
            }



          } // while ë£¨í”„ ë (ë°°ì¹˜ ì²˜ë¦¬ ì™„ë£Œ )
          // ë‹¤ìŒ ë°°ì¹˜ ì²˜ë¦¬ ì˜ˆì•½
          setTimeout(stepBatch, 0);

        }
        stepBatch(); // ë¯¸ë¡œ ìƒì„± ì‹œì‘ ë°°ì¹˜ ì²˜ë¦¬ ì‹œì‘
      }

      // --- ê²Œì„ ì§„í–‰ í•¨ìˆ˜ ---

      /**
       * ê²Œì„ì„ ì‹œì‘í•˜ëŠ” í•¨ìˆ˜.
       * ë ˆë²¨ì„ ì„¤ì •í•˜ê³ , ë¯¸ë¡œ í¬ê¸°ë¥¼ ê³„ì‚°í•˜ë©°, ê´€ë ¨ ë³€ìˆ˜ë“¤ì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
       * ë¯¸ë¡œ ìƒì„±, ì •ë‹µ ê²½ë¡œ ì°¾ê¸°, ê¸€ì ë°°ì¹˜, ê·¸ë¦¬ê¸°, íƒ€ì´ë¨¸ ì‹œì‘ ë“±ì„ ìˆœì°¨ì ìœ¼ë¡œ í˜¸ì¶œí•©ë‹ˆë‹¤.
       */
      function startGame() {
        // --- ë¡œë”© ì‹œì‘ ---
        const loadingOverlay = document.getElementById('loadingOverlay');
        const startGameBtn = document.getElementById('startGameBtn'); // ID ê°€ì •
        const showPathBtn = document.getElementById('showPathBtn');   // ID ê°€ì •
        const hidePathBtn = document.getElementById('hidePathBtn');   // ID ê°€ì •
        const levelSelect = document.getElementById('levelSelect');

        if (loadingOverlay) loadingOverlay.classList.remove('hidden');
        if (startGameBtn) startGameBtn.disabled = true;
        if (showPathBtn) showPathBtn.disabled = true;
        if (hidePathBtn) hidePathBtn.disabled = true;
        if (levelSelect) levelSelect.disabled = true;
        // ---------------

        stopTimer();
        // 1. ë ˆë²¨ ë° ì •ë‹µ ì„¤ì •
        const level = parseInt(document.getElementById("levelSelect").value);
        answer = answersList[level - 1]; // ì„ íƒëœ ë ˆë²¨ì— ë§ëŠ” ì •ë‹µ ë¬¸ì¥ ì„¤ì •

        // 2. ë¯¸ë¡œ í¬ê¸° ë° ì…€ í¬ê¸° ê³„ì‚° (ìº”ë²„ìŠ¤ í¬ê¸°ì— ë§ì¶° ë™ì  ì¡°ì ˆ)
        COLS = Math.floor(canvas.width / 40); // ê°€ë¡œ ì¹¸ ìˆ˜
        ROWS = Math.floor(canvas.height / 40); // ì„¸ë¡œ ì¹¸ ìˆ˜
        CELL = Math.min(canvas.width / COLS, canvas.height / ROWS); // ê° ì…€ì˜ í¬ê¸° (ì •ì‚¬ê°í˜• ìœ ì§€)

        // 3. ê²Œì„ ìƒíƒœ ì´ˆê¸°í™”
        player = { x: 0, y: 0 }; // í”Œë ˆì´ì–´ ìœ„ì¹˜ ì´ˆê¸°í™” (0, 0)
        moveStack = [{ x: 0, y: 0 }]; // ì´ë™ ê²½ë¡œ ìŠ¤íƒ ì´ˆê¸°í™” (ì‹œì‘ ìœ„ì¹˜ í¬í•¨)
        visitedCells = new Set(["0,0"]); // ë°©ë¬¸ ì…€ ê¸°ë¡ ì´ˆê¸°í™” (ì‹œì‘ ìœ„ì¹˜ í¬í•¨, "x,y" ë¬¸ìì—´ í˜•íƒœ)
        showPath = false; // ì •ë‹µ ê²½ë¡œ í‘œì‹œ í”Œë˜ê·¸ ì´ˆê¸°í™”
        document.getElementById("resultMsg").innerText = ""; // ê²°ê³¼ ë©”ì‹œì§€ ì´ˆê¸°í™”
        document.getElementById("answerInput").value = ""; // ì •ë‹µ ì…ë ¥ì°½ ì´ˆê¸°í™”

        generateMaze(() => {
          findAnswerPath();   // ì •ë‹µ ê²½ë¡œ ê³„ì‚°
          placeLetters();     // ì •ë‹µ ê²½ë¡œ ìœ„ì— ê¸€ì ë°°ì¹˜
          placeDecoyLetters(); // â˜…â˜…â˜… ë¯¸ë¼ ê¸€ì ë°°ì¹˜ í•¨ìˆ˜ í˜¸ì¶œ ì¶”ê°€ â˜…â˜…â˜…
          draw();             // ì´ˆê¸° ë¯¸ë¡œ ìƒíƒœ ê·¸ë¦¬ê¸°
          startTimer();       // ê²Œì„ íƒ€ì´ë¨¸ ì‹œì‘
          setupTouchControls(); // í„°ì¹˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì •
        });

        // --- ë¡œë”© ì™„ë£Œ ---
        if (loadingOverlay) loadingOverlay.classList.add('hidden');
        if (startGameBtn) startGameBtn.disabled = false;
        if (showPathBtn) showPathBtn.disabled = false;
        if (hidePathBtn) hidePathBtn.disabled = false;
        if (levelSelect) levelSelect.disabled = false;
        // ---------------
      }

      /**
       * ë¯¸ë¡œì˜ ì‹œì‘ì (0,0)ë¶€í„° ë„ì°©ì (COLS-1, ROWS-1)ê¹Œì§€ì˜ ì •ë‹µ ê²½ë¡œë¥¼ ì°¾ëŠ” í•¨ìˆ˜ (DFS ì‚¬ìš©).
       * ì°¾ì€ ê²½ë¡œëŠ” path ë°°ì—´ì— {i, j} ê°ì²´ í˜•íƒœë¡œ ì €ì¥ë©ë‹ˆë‹¤.
       */

      function findAnswerPathBackup() {
        path = []; // ê²½ë¡œ ë°°ì—´ ì´ˆê¸°í™”
        let visited = new Set(); // ê²½ë¡œ íƒìƒ‰ ì¤‘ ë°©ë¬¸ ì—¬ë¶€ ê¸°ë¡ (findAnswerPath í•¨ìˆ˜ ë‚´ì—ì„œë§Œ ì‚¬ìš©)

        // DFS íƒìƒ‰ í•¨ìˆ˜ (ì¬ê·€)
        function dfs(x, y) {
          // í˜„ì¬ ìœ„ì¹˜ë¥¼ ë¬¸ìì—´ "x,y" í˜•íƒœë¡œ visited Setì— ì¶”ê°€
          visited.add(x + "," + y);
          // í˜„ì¬ ìœ„ì¹˜ë¥¼ ê²½ë¡œ ë°°ì—´ pathì— ì¶”ê°€
          path.push({ i: x, j: y });

          // ë„ì°©ì ì— ë„ë‹¬í–ˆìœ¼ë©´ true ë°˜í™˜ (íƒìƒ‰ ì„±ê³µ)
          if (x === COLS - 1 && y === ROWS - 1) {
            return true;
          }

          // ì´ë™ ê°€ëŠ¥í•œ ë°©í–¥ ë°°ì—´ [ìš°, í•˜, ì¢Œ, ìƒ] (ìš°ì„ ìˆœìœ„ ë³€ê²½ ê°€ëŠ¥)
          let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];

          // ê° ë°©í–¥ìœ¼ë¡œ íƒìƒ‰ ì‹œë„
          for (let [dx, dy] of directions) {
            let nx = x + dx; // ë‹¤ìŒ x ì¢Œí‘œ
            let ny = y + dy; // ë‹¤ìŒ y ì¢Œí‘œ

            // ë‹¤ìŒ ìœ„ì¹˜ê°€ ë¯¸ë¡œ ë²”ìœ„ ë‚´ì— ìˆê³ , ì•„ì§ ë°©ë¬¸í•˜ì§€ ì•Šì•˜ëŠ”ì§€ í™•ì¸
            if (nx >= 0 && ny >= 0 && nx < COLS && ny < ROWS && !visited.has(nx + "," + ny)) {
              let currentCell = grid[index(x, y)]; // í˜„ì¬ ì…€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°

              // í˜„ì¬ ì…€ê³¼ ë‹¤ìŒ ì…€ ì‚¬ì´ì— ë²½ì´ ì—†ëŠ”ì§€ í™•ì¸ (ì´ë™ ê°€ëŠ¥í•œì§€ ì²´í¬)
              if (
                (dx == 1 && !currentCell.walls[1]) ||  // ì˜¤ë¥¸ìª½ ì´ë™ ì‹œ ì˜¤ë¥¸ìª½ ë²½ ì—†ìŒ
                (dx == -1 && !currentCell.walls[3]) || // ì™¼ìª½ ì´ë™ ì‹œ ì™¼ìª½ ë²½ ì—†ìŒ
                (dy == 1 && !currentCell.walls[2]) ||  // ì•„ë˜ìª½ ì´ë™ ì‹œ ì•„ë˜ìª½ ë²½ ì—†ìŒ
                (dy == -1 && !currentCell.walls[0])    // ìœ„ìª½ ì´ë™ ì‹œ ìœ„ìª½ ë²½ ì—†ìŒ
              ) {
                // ì´ë™ ê°€ëŠ¥í•˜ë©´ ë‹¤ìŒ ìœ„ì¹˜ì—ì„œ ì¬ê·€ì ìœ¼ë¡œ dfs í˜¸ì¶œ
                if (dfs(nx, ny)) {
                  return true; // ë„ì°©ì ì„ ì°¾ì•˜ìœ¼ë©´ trueë¥¼ ê³„ì† ë°˜í™˜í•˜ì—¬ ì¬ê·€ ì¢…ë£Œ
                }
              }
            }
          }

          // ëª¨ë“  ë°©í–¥ íƒìƒ‰ í›„ì—ë„ ë„ì°©ì ì„ ëª» ì°¾ìœ¼ë©´ ë§‰ë‹¤ë¥¸ ê¸¸ì´ë¯€ë¡œ ê²½ë¡œì—ì„œ í˜„ì¬ ìœ„ì¹˜ ì œê±°
          path.pop();
          return false; // íƒìƒ‰ ì‹¤íŒ¨(ë§‰ë‹¤ë¥¸ ê¸¸)ë¥¼ ì•Œë¦¼
        }
        dfs(0, 0); // ì‹œì‘ì (0,0)ì—ì„œ íƒìƒ‰ ì‹œì‘
      }

      function findAnswerPath() {
        path = [];
        let visited = new Set();
        function dfs(x, y) {
          if (x === COLS - 1 && y === ROWS - 1) {
            path.push({ i: x, j: y });
            return true;
          }
          visited.add(x + "," + y);
          path.push({ i: x, j: y });
          let directions = [[1, 0], [0, 1], [-1, 0], [0, -1]];
          // ë°©í–¥ ëœë¤ ì„ê¸°
          for (let i = directions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [directions[i], directions[j]] = [directions[j], directions[i]];
          }

          for (let [dx, dy] of directions) {
            let nx = x + dx;
            let ny = y + dy;
            if (nx >= 0 && ny >= 0 && nx < COLS && ny < ROWS && !visited.has(nx + "," + ny)) {
              let currentCell = grid[index(x, y)];
              if (
                (dx == 1 && !currentCell.walls[1]) ||
                (dx == -1 && !currentCell.walls[3]) ||
                (dy == 1 && !currentCell.walls[2]) ||
                (dy == -1 && !currentCell.walls[0])
              ) {
                if (dfs(nx, ny)) return true;
              }
            }
          }
          path.pop();
          return false;
        }
        dfs(0, 0);
      }

      /**
      * ì •ë‹µ ê²½ë¡œ ìœ„ì— ê¸€ìë¥¼ ìì—°ìŠ¤ëŸ½ê³  ëœë¤í•œ ê°„ê²© + **ì˜¬ë°”ë¥¸ ìˆœì„œ**ë¡œ ë°°ì¹˜í•˜ëŠ” í•¨ìˆ˜.
      */
      function placeLetters() {
        letters = []; // ê¸€ì ë°°ì—´ ì´ˆê¸°í™”
        const answerChars = answer.split(""); // ì •ë‹µ ë¬¸ì ë°°ì—´
        const N = answerChars.length; // ì •ë‹µ ë¬¸ì ê°œìˆ˜

        // ê²½ë¡œì—ì„œ ì‹œì‘ì (0)ê³¼ ë„ì°©ì (path.length-1)ì€ ì œì™¸
        const availablePathCoords = path.slice(1, -1);
        const L = availablePathCoords.length; // ì‚¬ìš© ê°€ëŠ¥í•œ ê²½ë¡œ ê¸¸ì´

        if (L < N) {
          console.error(`ê²½ë¡œ ê¸¸ì´ ë¶€ì¡±! ì‚¬ìš© ê°€ëŠ¥ ê²½ë¡œ: ${L}, í•„ìš”í•œ ê¸€ì ìˆ˜: ${N}`);
          // ë¹„ìƒ ë¡œì§: ìµœì†Œí•œì˜ ë°°ì¹˜ë¼ë„ ì‹œë„
          let step = Math.max(1, Math.floor(L / N));
          for (let i = 0; i < N; i++) {
            let idx = Math.min(i * step, L - 1);
            if (availablePathCoords[idx]) {
              letters.push({ x: availablePathCoords[idx].i, y: availablePathCoords[idx].j, char: answerChars[i], isAnswer: true });
            }
          }
          letters.push({ x: 0, y: 0, char: "ì¶œë°œ", isAnswer: false, isLabel: true });
          letters.push({ x: COLS - 1, y: ROWS - 1, char: "ë„ì°©", isAnswer: false, isLabel: true });
          return;
        }

        const occupiedIndices = new Set(); // ì‚¬ìš©ëœ availablePathCoords ì¸ë±ìŠ¤ ì €ì¥
        let lastPlacedIndex = -1; // â˜…â˜…â˜… ë§ˆì§€ë§‰ìœ¼ë¡œ ë°°ì¹˜ëœ ë¬¸ìì˜ availablePathCoords ì¸ë±ìŠ¤ ì¶”ì 

        // ê° ê¸€ìì— ëŒ€í•´ ìˆœì„œëŒ€ë¡œ ë°°ì¹˜ ìœ„ì¹˜ ê³„ì‚° ë° ì‹œë„
        for (let i = 0; i < N; i++) {
          let targetIndex;
          let offsetRange;
          // â˜…â˜…â˜… ë‹¤ìŒ ê¸€ìê°€ ì‹œì‘í•´ì•¼ í•  ìµœì†Œ ì¸ë±ìŠ¤ â˜…â˜…â˜…
          const searchStartIndex = lastPlacedIndex + 1;

          // 1. ì´ìƒì ì¸ ëª©í‘œ ì¸ë±ìŠ¤ ê³„ì‚° (ë¹„ìœ¨ ê¸°ë°˜, ì´ì „ê³¼ ë™ì¼)
          if (i === N - 1) { // ë§ˆì§€ë§‰ ê¸€ì ì²˜ë¦¬
            const endIndex = L - 1;
            const startIndex = Math.max(searchStartIndex, L - Math.ceil(L * 0.15)); // ì‹œì‘ ê°€ëŠ¥ ì¸ë±ìŠ¤ ê³ ë ¤
            targetIndex = startIndex + Math.floor(Math.random() * Math.max(0, (endIndex - startIndex + 1)));
            offsetRange = Math.floor(L / N * 0.3);
          } else { // ì¼ë°˜ ê¸€ì ì²˜ë¦¬
            // ëª©í‘œ ì¸ë±ìŠ¤ëŠ” ì „ì²´ ê²½ë¡œ ë¹„ìœ¨ ê¸°ì¤€, ë‹¨ searchStartIndexë³´ë‹¤ëŠ” ì»¤ì•¼ í•¨
            targetIndex = Math.max(searchStartIndex, Math.round(i * (L - 1) / (N - 1)));
            offsetRange = Math.floor(L / N * 0.4);
          }

          // 2. ëœë¤ ì˜¤í”„ì…‹ ì ìš©
          const randomOffset = Math.floor(Math.random() * (offsetRange * 2 + 1)) - offsetRange;
          let placementIndex = targetIndex + randomOffset;

          // 3. ì¸ë±ìŠ¤ ê²½ê³„ê°’ ì¡°ì • (â˜… searchStartIndex ì´ìƒ, L-1 ì´í•˜ â˜…)
          placementIndex = Math.max(searchStartIndex, Math.min(L - 1, placementIndex));

          // 4. ì¶©ëŒ ì²˜ë¦¬: placementIndexë¶€í„° ì‹œì‘í•˜ì—¬ *ë‹¤ìŒ* ë¹ˆ ê³³ ì°¾ê¸°
          let foundIndex = -1;
          for (let currentIdx = placementIndex; currentIdx < L; currentIdx++) {
            if (!occupiedIndices.has(currentIdx)) {
              foundIndex = currentIdx;
              break; // ì°¾ìœ¼ë©´ ë°”ë¡œ ì¢…ë£Œ
            }
          }

          // ë§Œì•½ ì•ì—ì„œ ëª» ì°¾ì•˜ë‹¤ë©´, placementIndexë¶€í„° *ì´ì „* (searchStartIndexê¹Œì§€) ë¹ˆ ê³³ ì°¾ê¸°
          if (foundIndex === -1) {
            for (let currentIdx = placementIndex - 1; currentIdx >= searchStartIndex; currentIdx--) {
              if (!occupiedIndices.has(currentIdx)) {
                foundIndex = currentIdx;
                break;
              }
            }
          }

          // 5. ë°°ì¹˜ ë˜ëŠ” ì˜¤ë¥˜ ì²˜ë¦¬
          if (foundIndex !== -1) {
            const p = availablePathCoords[foundIndex];
            letters.push({ x: p.i, y: p.j, char: answerChars[i], isAnswer: true });
            occupiedIndices.add(foundIndex); // ì‚¬ìš©ëœ ì¸ë±ìŠ¤ ê¸°ë¡
            lastPlacedIndex = foundIndex; // â˜…â˜…â˜… ë§ˆì§€ë§‰ ë°°ì¹˜ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
          } else {
            console.warn(`ê¸€ì '${answerChars[i]}' ë°°ì¹˜ ì‹¤íŒ¨! [${searchStartIndex}, ${L - 1}] ë²”ìœ„ ë‚´ ë¹ˆ ê³µê°„ ì—†ìŒ.`);
            // ë¹„ìƒ ë¡œì§: searchStartIndex ì´í›„ ì²« ë²ˆì§¸ ë¹ˆ ì¹¸ì— ê°•ì œ ë°°ì¹˜
            let emergencyIndex = -1;
            for (let tempIdx = searchStartIndex; tempIdx < L; tempIdx++) {
              if (!occupiedIndices.has(tempIdx)) {
                emergencyIndex = tempIdx;
                break;
              }
            }
            if (emergencyIndex !== -1) {
              const p = availablePathCoords[emergencyIndex];
              letters.push({ x: p.i, y: p.j, char: answerChars[i], isAnswer: true });
              occupiedIndices.add(emergencyIndex);
              lastPlacedIndex = emergencyIndex; // â˜…â˜…â˜… ë¹„ìƒ ë°°ì¹˜ ì¸ë±ìŠ¤ ì—…ë°ì´íŠ¸ â˜…â˜…â˜…
            } else {
              console.error(`!!! ë¹„ìƒ ë°°ì¹˜ì¡°ì°¨ ì‹¤íŒ¨ (${i + 1}ë²ˆì§¸ ê¸€ì) !!!`);
              // ë” ì´ìƒ ì§„í–‰ ë¶ˆê°€ ë˜ëŠ” ë‹¤ë¥¸ ì²˜ë¦¬
            }
          }
        }

        // ì‹œì‘ì ê³¼ ë„ì°©ì  ë ˆì´ë¸” ì¶”ê°€
        letters.push({ x: 0, y: 0, char: "ì¶œë°œ", isAnswer: false, isLabel: true });
        letters.push({ x: COLS - 1, y: ROWS - 1, char: "ë„ì°©", isAnswer: false, isLabel: true });

        console.log(`ê¸€ì ë°°ì¹˜ ì™„ë£Œ (ìˆœì„œ ë³´ì¥ ì‹œë„)`);
      }

      /**
       * ìº”ë²„ìŠ¤ì— í˜„ì¬ ê²Œì„ ìƒíƒœ (ë¯¸ë¡œ, ê¸€ì, í”Œë ˆì´ì–´, ì •ë‹µ ê²½ë¡œ ë“±)ë¥¼ ê·¸ë¦¬ëŠ” í•¨ìˆ˜.
       * ê²Œì„ ìƒíƒœê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ í˜¸ì¶œë˜ì–´ í™”ë©´ì„ ì—…ë°ì´íŠ¸.
       */
      function draw() {
        // 1. ìº”ë²„ìŠ¤ ì´ˆê¸°í™” (ì´ì „ ê·¸ë¦¼ ì§€ìš°ê¸°)
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 2. ë¯¸ë¡œ ë²½ ê·¸ë¦¬ê¸°
        for (let c of grid) {
          let x = c.i * CELL; // ì…€ì˜ í™”ë©´ x ì¢Œí‘œ
          let y = c.j * CELL; // ì…€ì˜ í™”ë©´ y ì¢Œí‘œ
          ctx.strokeStyle = "black"; // ë²½ ìƒ‰ìƒ
          ctx.lineWidth = 2; // ë²½ ë‘ê»˜

          // ê° ì…€ì˜ walls ë°°ì—´ ìƒíƒœì— ë”°ë¼ ë²½ ê·¸ë¦¬ê¸°
          if (c.walls[0]) { ctx.beginPath(); ctx.moveTo(x, y); ctx.lineTo(x + CELL, y); ctx.stroke(); } // ìƒë‹¨ ë²½
          if (c.walls[1]) { ctx.beginPath(); ctx.moveTo(x + CELL, y); ctx.lineTo(x + CELL, y + CELL); ctx.stroke(); } // ìš°ì¸¡ ë²½
          if (c.walls[2]) { ctx.beginPath(); ctx.moveTo(x + CELL, y + CELL); ctx.lineTo(x, y + CELL); ctx.stroke(); } // í•˜ë‹¨ ë²½
          if (c.walls[3]) { ctx.beginPath(); ctx.moveTo(x, y + CELL); ctx.lineTo(x, y); ctx.stroke(); } // ì¢Œì¸¡ ë²½
        }

        // 3. ì •ë‹µ ê²½ë¡œ ê·¸ë¦¬ê¸° (showPath í”Œë˜ê·¸ê°€ trueì¼ ë•Œë§Œ)
        if (showPath) {
          ctx.strokeStyle = "#00ffff"; // ê²½ë¡œ ìƒ‰ìƒ
          ctx.lineWidth = 4; // ê²½ë¡œ ë‘ê»˜
          ctx.beginPath();
          // ê²½ë¡œì˜ ì‹œì‘ì ì—ì„œ ì„  ê·¸ë¦¬ê¸° ì‹œì‘
          ctx.moveTo(path[0].i * CELL + CELL / 2, path[0].j * CELL + CELL / 2);
          // ê²½ë¡œì˜ ê° ì ì„ ìˆœì„œëŒ€ë¡œ ì—°ê²°
          for (let p of path) {
            ctx.lineTo(p.i * CELL + CELL / 2, p.j * CELL + CELL / 2);
          }
          ctx.stroke(); // ê²½ë¡œ ê·¸ë¦¬ê¸° ì™„ë£Œ
        }

        // 4. ê¸€ì ê·¸ë¦¬ê¸°
        for (let l of letters) {
          // ê¸€ì ìƒ‰ìƒ ì„¤ì •: ì •ë‹µ ê¸€ìì´ê³  í•´ë‹¹ ì…€ì„ ë°©ë¬¸í–ˆìœ¼ë©´('visitedCells'ì— ìˆìœ¼ë©´) ë¹¨ê°„ìƒ‰, ì•„ë‹ˆë©´ ê²€ì€ìƒ‰
          ctx.fillStyle = l.isAnswer && visitedCells.has(`${l.x},${l.y}`) ? "red" : "black";
          // í°íŠ¸ ì„¤ì •: ë ˆì´ë¸”(ì¶œë°œ/ë„ì°©)ê³¼ ì¼ë°˜ ê¸€ì í¬ê¸° ë‹¤ë¥´ê²Œ ì„¤ì •
          ctx.font = l.isLabel ? `${CELL / 4}px sans-serif` : `${CELL / 3}px sans-serif`;
          ctx.textAlign = "center"; // ê°€ë¡œ ì¤‘ì•™ ì •ë ¬
          ctx.textBaseline = "middle"; // ì„¸ë¡œ ì¤‘ì•™ ì •ë ¬
          // ì…€ ì¤‘ì•™ì— ê¸€ì ê·¸ë¦¬ê¸°
          ctx.fillText(l.char, l.x * CELL + CELL / 2, l.y * CELL + CELL / 2);
        }

        // 5. í”Œë ˆì´ì–´ ê·¸ë¦¬ê¸°
        ctx.fillStyle = "blue"; // í”Œë ˆì´ì–´ ìƒ‰ìƒ
        // í”Œë ˆì´ì–´ ìœ„ì¹˜ì— ì‚¬ê°í˜• ê·¸ë¦¬ê¸° (ì…€ ì¤‘ì•™ì— ìœ„ì¹˜í•˜ë„ë¡)
        ctx.fillRect(player.x * CELL + CELL / 4, player.y * CELL + CELL / 4, CELL / 2, CELL / 2);
      }

      /**
       * í”Œë ˆì´ì–´ë¥¼ ì§€ì •ëœ ë°©í–¥(dx, dy)ìœ¼ë¡œ ì´ë™ì‹œí‚¤ëŠ” í•¨ìˆ˜.
       * ë²½ ì¶©ëŒ ì²´í¬, ì´ë™ ì²˜ë¦¬, ì´ë™ ê¸°ë¡(moveStack, visitedCells) ì—…ë°ì´íŠ¸, í™”ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸°ë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
       * @param {number} dx - xì¶• ì´ë™ëŸ‰ (-1: ì¢Œ, 1: ìš°, 0: ì´ë™ ì—†ìŒ)
       * @param {number} dy - yì¶• ì´ë™ëŸ‰ (-1: ìƒ, 1: í•˜, 0: ì´ë™ ì—†ìŒ)
       */
      function move(dx, dy) {
        // 1. ë‹¤ìŒ ì˜ˆìƒ ìœ„ì¹˜ ê³„ì‚°
        let nextX = player.x + dx;
        let nextY = player.y + dy;

        // 2. ë¯¸ë¡œ ë²”ìœ„ ë²—ì–´ë‚˜ëŠ”ì§€ í™•ì¸
        if (nextX < 0 || nextY < 0 || nextX >= COLS || nextY >= ROWS) return; // ë²—ì–´ë‚˜ë©´ ì´ë™ ë¶ˆê°€

        // 3. í˜„ì¬ ì…€ê³¼ ë‹¤ìŒ ì…€ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        let currentCell = grid[index(player.x, player.y)];
        let nextCell = grid[index(nextX, nextY)]; // ë‹¤ìŒ ì…€ ì •ë³´ (ì—†ì„ ìˆ˜ë„ ìˆì§€ë§Œ, ë²”ìœ„ ì²´í¬ë¡œ ì‚¬ì‹¤ìƒ í•­ìƒ ìˆìŒ)
        if (!nextCell) return; // í˜¹ì‹œ ëª¨ë¥¼ ì˜¤ë¥˜ ë°©ì§€

        // 4. ë²½ ì¶©ëŒ í™•ì¸ ë° ì´ë™ ì²˜ë¦¬
        let moved = false; // ì´ë™ ì„±ê³µ ì—¬ë¶€ í”Œë˜ê·¸
        if (dx === 1 && !currentCell.walls[1]) { player.x++; moved = true; } // ì˜¤ë¥¸ìª½ ì´ë™ (ë²½ ì—†ìœ¼ë©´)
        if (dx === -1 && !currentCell.walls[3]) { player.x--; moved = true; } // ì™¼ìª½ ì´ë™ (ë²½ ì—†ìœ¼ë©´)
        if (dy === 1 && !currentCell.walls[2]) { player.y++; moved = true; } // ì•„ë˜ìª½ ì´ë™ (ë²½ ì—†ìœ¼ë©´)
        if (dy === -1 && !currentCell.walls[0]) { player.y--; moved = true; } // ìœ„ìª½ ì´ë™ (ë²½ ì—†ìœ¼ë©´)

        // 5. ì´ë™ ì„±ê³µ ì‹œ í›„ì²˜ë¦¬
        if (moved) {
          // ì´ë™í•œ ìœ„ì¹˜ë¥¼ moveStackì— ì¶”ê°€ (ë˜ëŒì•„ê°€ê¸° ìš©ë„)
          moveStack.push({ x: player.x, y: player.y });
          // ì´ë™í•œ ìœ„ì¹˜ë¥¼ visitedCells Setì— ì¶”ê°€ (ë°©ë¬¸ ê¸°ë¡, ê¸€ì ìƒ‰ ë³€ê²½ ìš©ë„)
          visitedCells.add(`${player.x},${player.y}`);
          draw(); // ë³€ê²½ëœ ìƒíƒœë¥¼ ìº”ë²„ìŠ¤ì— ë‹¤ì‹œ ê·¸ë¦¼
        }
      }

      /**
       * í”Œë ˆì´ì–´ì˜ ë§ˆì§€ë§‰ ì´ë™ì„ ì·¨ì†Œí•˜ëŠ” í•¨ìˆ˜ (ë˜ëŒì•„ê°€ê¸°).
       * Backspace í‚¤ ì…ë ¥ ì‹œ í˜¸ì¶œë©ë‹ˆë‹¤.
       * moveStackê³¼ visitedCellsë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  í™”ë©´ì„ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
       */
      function undoMove() {
        // ìŠ¤íƒì— 2ê°œ ì´ìƒì˜ ìœ„ì¹˜ê°€ ìˆì–´ì•¼ ë˜ëŒì•„ê°ˆ ìˆ˜ ìˆìŒ (ì‹œì‘ ìœ„ì¹˜ëŠ” ë‚¨ê²¨ì•¼ í•¨)
        if (moveStack.length > 1) {
          // 1. í˜„ì¬ ìœ„ì¹˜(ë˜ëŒì•„ê°€ê¸° ì „ ìœ„ì¹˜)ë¥¼ visitedCellsì—ì„œ ì œê±°
          //    -> ì´ ì¹¸ì˜ ê¸€ìê°€ ë‹¤ì‹œ ê²€ì€ìƒ‰ìœ¼ë¡œ ê·¸ë ¤ì§€ë„ë¡ í•¨.
          visitedCells.delete(`${player.x},${player.y}`);

          // 2. moveStackì—ì„œ ë§ˆì§€ë§‰ ìœ„ì¹˜(í˜„ì¬ ìœ„ì¹˜) ì œê±°
          moveStack.pop();

          // 3. ìŠ¤íƒì˜ ìƒˆë¡œìš´ ë§ˆì§€ë§‰ ìœ„ì¹˜(ì´ì „ ìœ„ì¹˜)ë¡œ í”Œë ˆì´ì–´ ì¢Œí‘œ ì—…ë°ì´íŠ¸
          let prev = moveStack[moveStack.length - 1];
          player.x = prev.x;
          player.y = prev.y;

          // 4. í™”ë©´ ë‹¤ì‹œ ê·¸ë¦¬ê¸° (ìˆ˜ì •ëœ visitedCells ìƒíƒœ ë°˜ì˜)
          draw();
        }
      }

      // --- íƒ€ì´ë¨¸ ê´€ë ¨ í•¨ìˆ˜ ---

      /**
       * ê²Œì„ ê²½ê³¼ ì‹œê°„ íƒ€ì´ë¨¸ë¥¼ ì‹œì‘í•˜ëŠ” í•¨ìˆ˜.
       * 1ì´ˆë§ˆë‹¤ ê²½ê³¼ ì‹œê°„ì„ ê³„ì‚°í•˜ì—¬ í™”ë©´ì— ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
       */
      function startTimer() {
        timerStart = Date.now(); // í˜„ì¬ ì‹œê°„ ê¸°ë¡ (ë°€ë¦¬ì´ˆ ë‹¨ìœ„)
        clearInterval(interval); // ì´ì „ì— ì‹¤í–‰ ì¤‘ì´ë˜ íƒ€ì´ë¨¸ê°€ ìˆë‹¤ë©´ ì¤‘ì§€
        // 0.5ì´ˆ(500ms)ë§ˆë‹¤ í•¨ìˆ˜ ì‹¤í–‰ (ë” ë¶€ë“œëŸ¬ìš´ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ 1ì´ˆë³´ë‹¤ ì§§ê²Œ ì„¤ì • ê°€ëŠ¥)
        interval = setInterval(() => {
          let now = Date.now();
          let sec = Math.floor((now - timerStart) / 1000); // ê²½ê³¼ ì‹œê°„ (ì´ˆ) ê³„ì‚°
          document.getElementById("timer").innerText = `â± ê²½ê³¼ ì‹œê°„: ${sec}ì´ˆ`; // í™”ë©´ ì—…ë°ì´íŠ¸
        }, 500);
      }

      function stopTimer() {

        clearInterval(interval);
        document.getElementById("timer").innerText = 'â± ê²½ê³¼ ì‹œê°„: 0ì´ˆ';
      }

      // --- ì…ë ¥ ì²˜ë¦¬ ê´€ë ¨ í•¨ìˆ˜ ---

      /**
       * ëª¨ë°”ì¼ í™˜ê²½ì„ ìœ„í•œ í„°ì¹˜ ì…ë ¥ ì²˜ë¦¬ ì„¤ì • í•¨ìˆ˜.
       * í„°ì¹˜ ì‹œì‘ì ê³¼ ëì ì˜ ì¢Œí‘œ ì°¨ì´ë¥¼ ì´ìš©í•´ ìƒí•˜ì¢Œìš° ìŠ¤ì™€ì´í”„ ë°©í–¥ì„ ê°ì§€í•˜ê³  move í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
       */
      function setupTouchControls() {
        let startX, startY; // í„°ì¹˜ ì‹œì‘ ì¢Œí‘œ

        // í„°ì¹˜ ì‹œì‘ ì‹œ ì¢Œí‘œ ê¸°ë¡
        canvas.addEventListener("touchstart", e => {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        });


        // í„°ì¹˜ ì¢…ë£Œ ì‹œ ì´ë™ ë°©í–¥ ê³„ì‚° ë° move í˜¸ì¶œ
        canvas.addEventListener("touchend", e => {
          let dx = e.changedTouches[0].clientX - startX; // xì¶• ì´ë™ëŸ‰
          let dy = e.changedTouches[0].clientY - startY; // yì¶• ì´ë™ëŸ‰
          let threshold = 30; // ìµœì†Œ ì´ë™ ê±°ë¦¬ (ì§§ì€ í„°ì¹˜ëŠ” ë¬´ì‹œ)

          // ê°€ë¡œ ì´ë™ëŸ‰ì´ ì„¸ë¡œ ì´ë™ëŸ‰ë³´ë‹¤ í¬ë©´ ì¢Œìš° ì´ë™
          if (Math.abs(dx) > Math.abs(dy)) {
            if (dx > threshold) move(1, 0);    // ì˜¤ë¥¸ìª½ ìŠ¤ì™€ì´í”„
            else if (dx < -threshold) move(-1, 0); // ì™¼ìª½ ìŠ¤ì™€ì´í”„
          }
          // ì„¸ë¡œ ì´ë™ëŸ‰ì´ ê°€ë¡œ ì´ë™ëŸ‰ë³´ë‹¤ í¬ë©´ ìƒí•˜ ì´ë™
          else {
            if (dy > threshold) move(0, 1);    // ì•„ë˜ìª½ ìŠ¤ì™€ì´í”„
            else if (dy < -threshold) move(0, -1); // ìœ„ìª½ ìŠ¤ì™€ì´í”„
          }
        });
      }

      // í‚¤ë³´ë“œ ì…ë ¥ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì„¤ì • (ì „ì²´ ë¬¸ì„œì— ì ìš©)
      document.addEventListener("keydown", function (event) {
        // ëˆŒë¦° í‚¤ì— ë”°ë¼ move ë˜ëŠ” undoMove í•¨ìˆ˜ í˜¸ì¶œ
        if (event.key === "ArrowUp") move(0, -1);
        if (event.key === "ArrowDown") move(0, 1);
        if (event.key === "ArrowLeft") move(-1, 0);
        if (event.key === "ArrowRight") move(1, 0);
        if (event.key === "Backspace") undoMove(); // Backspace í‚¤ë¡œ ë˜ëŒì•„ê°€ê¸°
      });

      // --- ì •ë‹µ í™•ì¸ ë° ê²½ë¡œ í‘œì‹œ í•¨ìˆ˜ ---

      /**
       * ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë‹µê³¼ ì‹¤ì œ ì •ë‹µì„ ë¹„êµí•˜ëŠ” í•¨ìˆ˜.
       * ê²°ê³¼ë¥¼ í™”ë©´ì— í‘œì‹œí•˜ê³ , ì˜¤ë‹µ ì‹œ í”ë“¤ë¦¼ íš¨ê³¼ë¥¼ ì¤ë‹ˆë‹¤.
       */
      function checkAnswer() {
        const input = document.getElementById("answerInput").value.trim(); // ì…ë ¥ê°’ ì–‘ìª½ ê³µë°± ì œê±°
        if (input === answer) { // ì •ë‹µì¼ ê²½ìš°
          clearInterval(interval); // íƒ€ì´ë¨¸ ë©ˆì¶¤
          document.getElementById("resultMsg").innerText = `ì •ë‹µì…ë‹ˆë‹¤! ğŸ¯`; // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        } else { // ì˜¤ë‹µì¼ ê²½ìš°
          document.body.classList.add("shake"); // body ìš”ì†Œì— shake í´ë˜ìŠ¤ ì¶”ê°€ (CSS ì• ë‹ˆë©”ì´ì…˜ ì‹¤í–‰)
          // 0.3ì´ˆ í›„ shake í´ë˜ìŠ¤ ì œê±° (ì• ë‹ˆë©”ì´ì…˜ ì¢…ë£Œ í›„ ì›ë˜ ìƒíƒœë¡œ)
          setTimeout(() => document.body.classList.remove("shake"), 300);
          document.getElementById("resultMsg").innerText = "ì˜¤ë‹µì…ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”."; // ì‹¤íŒ¨ ë©”ì‹œì§€ í‘œì‹œ
        }
      }

      /**
       * ì •ë‹µ ê²½ë¡œë¥¼ í™”ë©´ì— í‘œì‹œí•˜ëŠ” í•¨ìˆ˜.
       */
      function showAnswerPath() {
        showPath = true; // ê²½ë¡œ í‘œì‹œ í”Œë˜ê·¸ ì„¤ì •
        draw(); // ë³€ê²½ëœ í”Œë˜ê·¸ë¥¼ ë°˜ì˜í•˜ì—¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      }

      /**
       * í™”ë©´ì— í‘œì‹œëœ ì •ë‹µ ê²½ë¡œë¥¼ ìˆ¨ê¸°ëŠ” í•¨ìˆ˜.
       */
      function hideAnswerPath() {
        showPath = false; // ê²½ë¡œ í‘œì‹œ í”Œë˜ê·¸ í•´ì œ
        draw(); // ë³€ê²½ëœ í”Œë˜ê·¸ë¥¼ ë°˜ì˜í•˜ì—¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
      }

      /**
       * ë¯¸ë¡œì˜ ë¹ˆ ê³µê°„(ì •ë‹µ ê²½ë¡œ, ì¶œë°œ/ë„ì°© ì œì™¸)ì—
       * í˜„ì¬ ë ˆë²¨ì˜ ì •ë‹µ ë¬¸ì¥ì—ì„œ ê°€ì ¸ì˜¨ ë¬´ì‘ìœ„ ê¸€ì(ë¯¸ë¼ ê¸€ì)ë¥¼ ë°°ì¹˜í•˜ëŠ” í•¨ìˆ˜.
       */

      function placeDecoyLetters() {
        const occupiedCoords = new Set(); // ì´ë¯¸ ê¸€ì(ì •ë‹µ, ì¶œë°œ, ë„ì°©)ê°€ ìˆëŠ” ì¢Œí‘œ ì €ì¥

        // ê¸°ì¡´ letters ë°°ì—´ì— ìˆëŠ” ëª¨ë“  ì¢Œí‘œë¥¼ Setì— ì¶”ê°€ (ë¹ ë¥¸ ì¡°íšŒë¥¼ ìœ„í•´)
        letters.forEach(l => occupiedCoords.add(`${l.x},${l.y}`));

        const availableCells = []; // ë¯¸ë¼ ê¸€ìë¥¼ ë°°ì¹˜í•  ìˆ˜ ìˆëŠ” ë¹ˆ ì…€ ëª©ë¡

        // ëª¨ë“  ê·¸ë¦¬ë“œ ì…€ì„ ìˆœíšŒ
        for (let j = 0; j < ROWS; j++) {
          for (let i = 0; i < COLS; i++) {
            // í˜„ì¬ ì…€ ì¢Œí‘œê°€ occupiedCoordsì— ì—†ìœ¼ë©´ (ì¦‰, ë¹„ì–´ ìˆìœ¼ë©´)
            if (!occupiedCoords.has(`${i},${j}`)) {
              availableCells.push({ x: i, y: j }); // ì‚¬ìš© ê°€ëŠ¥í•œ ì…€ ëª©ë¡ì— ì¶”ê°€
            }
          }
        }

        // ë¯¸ë¼ ê¸€ì ìˆ˜ ê²°ì • (ì˜ˆ: ì •ë‹µ ê¸¸ì´ì˜ ì ˆë°˜ ë˜ëŠ” ì‚¬ìš© ê°€ëŠ¥í•œ ì…€ì˜ 10% ë“±, ìµœëŒ€ì¹˜ëŠ” ë¹ˆ ì…€ ìˆ˜)
        // ì—¬ê¸°ì„œëŠ” ì •ë‹µ ê¸¸ì´ì˜ ì ˆë°˜ ì •ë„ë¡œ ì„¤ì •í•˜ë˜, ë¹ˆ ì…€ ìˆ˜ë³´ë‹¤ëŠ” ë§ì§€ ì•Šê²Œ í•©ë‹ˆë‹¤.
        const numDecoys = availableCells.length - answer.length * 2;
        // const numDecoys = Math.min(Math.floor(availableCells.length * 0.5), answer.length);

        // ì‚¬ìš© ê°€ëŠ¥í•œ ì…€ ëª©ë¡ì„ ë¬´ì‘ìœ„ë¡œ ì„ìŒ (Fisher-Yates Shuffle)
        for (let i = availableCells.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [availableCells[i], availableCells[j]] = [availableCells[j], availableCells[i]];
        }

        // ê²°ì •ëœ ìˆ˜ë§Œí¼ ë¯¸ë¼ ê¸€ì ë°°ì¹˜
        for (let k = 0; k < numDecoys; k++) {
          const cell = availableCells[k]; // ì„ì¸ ëª©ë¡ì—ì„œ ì…€ í•˜ë‚˜ ì„ íƒ
          // ì •ë‹µ ë¬¸ìì—´ì—ì„œ ë¬´ì‘ìœ„ë¡œ ê¸€ì í•˜ë‚˜ ì„ íƒ
          const randomChar = answer[Math.floor(Math.random() * answer.length)];

          // path ë°°ì—´ì—ì„œ í˜„ì¬ cellì˜ ì¢Œí‘œ(x, y)ì™€ ë™ì¼í•œ ì¢Œí‘œ(i, j)ë¥¼ ê°€ì§„ ìš”ì†Œê°€ ìˆëŠ”ì§€ í™•ì¸
          if (path.find(p => p.i === cell.x && p.j === cell.y)) {
            continue; // ê²½ë¡œ ìƒì— ìˆëŠ” ì¢Œí‘œë¼ë©´ ì´ ì…€ì—ëŠ” ë¯¸ë¼ ê¸€ìë¥¼ ë†“ì§€ ì•Šê³  ë‹¤ìŒ ì…€ë¡œ ë„˜ì–´ê°
          }

          // ë¯¸ë¼ ê¸€ì ê°ì²´ ìƒì„± ë° letters ë°°ì—´ì— ì¶”ê°€
          letters.push({
            x: cell.x,
            y: cell.y,
            char: randomChar,
            isAnswer: false, // ì •ë‹µ ê²½ë¡œ ê¸€ìê°€ ì•„ë‹˜
            isDecoy: true    // ë¯¸ë¼ ê¸€ìì„ì„ í‘œì‹œ (ì„ íƒì , ë‚˜ì¤‘ì— ìŠ¤íƒ€ì¼ë§ ë“±ì— í™œìš© ê°€ëŠ¥)
          });
        }
      }

    </script>

  </body>

</html>
