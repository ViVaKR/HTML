@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Archivo+Black&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Story+Script&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Cute+Font&display=swap');

@import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&display=swap');

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html,
body {
  font-size: 100%;
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-size: 1rem;
}

body {
  // font-family: 'Roboto', 'Cute Font', sans-serif;
  font-family: 'Roboto', 'IBM Plex Sans KR', sans-serif;
  font-weight: 400;
  font-style: normal;
  line-height: 1.5rem;
}

.container {
  display: flex;
  flex-direction: column;
  gap: 3rem;
  margin: 1rem;
}

// before
h4#subtitle {
  line-height: 24px;

  height: 75px;
  background-color: rgba(52, 170, 213, 0.5);
  display: table-cell;
  padding: 10px;
  vertical-align: baseline;
}
#subtitle:before {
  content: '🏋️‍♂️ ';
  vertical-align: baseline;
  margin-right: 0.3em;
}

// 메뉴바
nav > ul {
  display: flex;
  flex-direction: row;
  margin: 0;
  padding: 0;

  li {
    list-style: none;
    &:not(:last-child)::after {
      content: '';
      display: inline-block;
      width: 1px;
      height: 0.8em;
      background-color: rgba(0, 0, 0, 0.6);
      margin: 0 1.1em;
      vertical-align: -0.06em;
      white-space: nowrap;
    }
  }

  li:before {
    content: ' ';
  }

  a {
    color: inherit;
    text-decoration: none;
    &:hover {
      text-decoration: underline;
    }
  }
}

// 앞으로 가기 버튼
#forward-link {
  color: inherit;
  text-decoration: none;
  padding: 0.5em 1em;
  background-color: #fff;
  border: 1px solid #777;
  border-radius: 0.5em;
  display: inline-flex;
  align-items: center;
}

#forward-link:after {
  content: '';
  display: inline-block;
  width: 0.5em;
  height: 0.5em;
  border-left: 1px solid black;
  border-bottom: 1px solid black;
  margin-left: 0.2em;
  transform: rotateZ(225deg);
}

h2::after {
  content: ' ';
  display: block;
  background-color: #000;
  width: 2em;
  height: 0.3em;
  margin-top: 0.3em;
}

#btn-like {
  padding: 0.5rem;
  border: none;
  border-radius: 0.6rem;
  background-color: rgba(125, 0, 255, 0.7);
  cursor: pointer;
  font-size: 2rem;
  &:hover {
    background-color: rgba(255, 0, 125, 0.5) !important;
  }
}
// #btn-like:hover {
//   background-color: rgba(255, 0, 125, 0.5) !important;
// }

// after, before 에는 content 속성은 필수임.
#btn-like::after {
  content: '🩷 ';
}

#hello-world {
  list-style-type: none;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  li {
    padding: 0.5rem;
    border-radius: 0.5rem;
  }
}

li::before {
  content: '✨ ';
}
// 첫번째 줄을 포함하여 1, 3, 5, 7, 9 ...
#hello-world > li:nth-child(2n + 1) {
  background-color: rgba(213, 84, 52, 0.71);
}

#lorems > div:nth-child(even) {
  background-color: rgba(52, 170, 213, 0.71);
}

/*
  * > :  직계 자손만 선택
*/

div > p {
  background-color: yellowgreen;
  margin: 5px 0;
  padding: 0.5rem;
}

article {
  border: 1px dashed red;
}

// 형제 요소
// h1 의 모든 형제 요소 중 div 요소의 모든 직계 자식 p 요소
h1 ~ div > p {
  background-color: rgba($color: #ff00ff, $alpha: 0.5);
}

// $ div>lorem5*10
// #lorem-first 요소의 형제 요소중 다음 첫번째 요소
#lorem-first + div {
  color: white;
}

article > div {
  display: flex;
  flex-direction: column;
  row-gap: 1rem;
  padding: 0.5rem;
}

/*
    - px : 절대단위, 고정된 크기의 픽셀 수
    - em : 상대단위, 부모 요소의 font-size 값을 기준으로 크기가 결정
            일반적으로 글꼴 크기, 여백(padding, margin) 등을 정의할 때 사용함.
            ex) 부모요소 - 60px, 자식 요소 : 0.8em --> 실제 크기 48px

    - 1rem : 16px
    - rem : 상대단위, 최상위 요소 (<html>) 의 font-size 값을 기준으로 크기가 결정됨
            일관된 요소의 크기로 반응형 디자인에 유리

            브라우저(html)의 기본 폰트 사이즈는 16px 이므로 ...

            ex) 12px => 12 / 16 = 0.75rem
            ex) 24px => 24 / 16 = 1.5rem
            * 16px => 1rem
            * 10px => html { font-size: 62.5% }

    - vw, vh :

    - sv* : 작은 뷰포트, 콘텐츠가 절대 잘리지 않음 부드러운 스크롤 경험 보장, 중요한 콘텐츠
        * 브라우저의 모든 동적인 요소 가 최대로 확장되어 나타나 있을때의 뷰포트를 기준으로 함
        * 즉, 브라우저 UI 가 모두 보이는 상태에서 측정된 고정값
        * 브라우저 UI 가 나타나거나 사라져도 변하지 않음
        * 절대 잘리면 안되는 중요한 콘텐츠
        * 고정된 헤더, 푸터, 알림 메시지 배치에 유용
        * 100svh 를 사용하면 콘텐츠가 주소창에 의해 가려지는 일이 없게 할 수 있음.

    - lv* : 큰 뷰포트, 최대한 큰 화면 활용 시각적 임팩트 극대화,풀스크린 배경이나 이미지

    - dv* : 동적 뷰포트, 특별한 상황에서 사용


    ? svh/svw, lvh/lvw, dvh/dvw
        => 동적인 브라우저 UI 요소 (주소 표시줄, 하단바 등) 가 있는 상태/없는 상태를 기준으로 뷰포트 크기를 계산

    - 자손 선택 : `요소 공백 요소`
    - 직계 자식 선태자 `요소 > 요소`

*/
