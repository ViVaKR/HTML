/*
  ! Containing Block
  - 요소의 박스와 연관된 박스들의 크기 조정 및 위치 지정을 결정하는 기반이 되는 직사각형.
  - 기반이 되는 부모 또는 조상 요소를 Conaining Block 이라고 함.
  - 뷰포트 (viewport) ; 웹 페이지가 보여지는 영역을 의미함.
  - 문서에서 최상위 요소인 <html> 의 containing Block 을 Initial Containing Block 이라고 함.
  - 전체 미디어는 뷰포트와 동일, 인쇄물에서는 페이지 영역과 동일 의미.
  - 문서의 요소 : Content box, Padding box, Border box, Magin area

  - position 별 구분
  * static : 자체가 기준점이 됨
  * relative : 자체가 기준점이 됨
  * sticky : 자체가 기준점이 됨
  * absolute : 가장 가까운 relative, absolute, fixed, sticky 인 조상요소의 Padding box, 없으면 <html> box
  * fixed  : Initial Containing Block (<html> 뷰포트) 이 Containing Block 이 됨.



*/

/*
  본 CSS 는 페이지의 기본 스타일을 정의함.
  선택자

  !important

  CSS 변수는 CSS Custom Properties 라는 이름으로 2015년에 도입되었고,

  - 문서전체에서 사용할 변수 설정 선택자 : `:root` 또는 `:body` 로 사용하면됨.
  - 만약 `.container` 라는 클래스 내부의 자손 요소에서만 사용할 변수는 `.container` 를 사용함.
  - 변수 이름은 기호 `--` 기호 뒤에 사용할 변수이름을 사용함.

*/

/* 스타일 시트의 문자 인코딩 지정 규칙, 스타일 시트의 첫 번째 최상당네 위치해야 함. */
/* 스타일 시트에서 한번만 사용할 수 있음. */
/* 대소문자 구분하지 않음  */
/* 큰 따옴표로 묶어야 함 */
/* 한개 이상의 띄여쓰기를 하면안됨 */
/* @charset "charset-name" */
/* HTML 에서 해당 인코딩을 선언하면 사용할 필요는 없음 */

/*
  ! 선택자 !

  - '*' : 전체 선택자, ::before, ::after 는 없음.
    * {
      color: #222;
    }

  - element : 유형선택자, 주어지 이름을 가진 모든 요소를 선택
  - [attribute] : 속성 이름이 일치하는 속성 선택,
  - [attribute="value"] : 이름과 값이 있는 속성 선택
  - [attribute*="value"] : 특정 단어를 포함하고 있는 값이 있는 속성 선택, 띄여쓰기로 구분되어 있지 않아도 됨
  - [attirbute~="value"] : 띄여쓰기로 구분된 단어중 정확히 'value' 라는 단어와 이치하는 값이 있는 속성 포함
  - [attribute^="value"] : 특정 단어로 시작하는 값이 있는 속성 선택
  - [attribute$="value"] : 특정 단어로 끝나는 값이 있는 속성 선택
  - #id : 아이디 선택자, id 값으로 속성 선택
  - .class : 클래스 선택자, 클래스 이름으로 요소 선택
  - A, B : 선택자 목록, 쉼표로 구분하여 A 와 B 를 모두 선택합니다.
    * .container p { // container 클래스 내부 하위의 깊이에 관계없이 모든 p 요소를 선택 }
  - A B : 자손 선택자 (Descendant combinator, 공백), A 모든 자손 요소 모두를 선택합다.
    * div p { // div 요소 하위의 모든 p 요소를 선택 }
  - A > B: 자식 선택자 (Child combinator, > ), A의 첫번째 직계 자식 요소만을 선택합니다.
    * .title ~ p { // title 클래스 뒤에 오는 모든 형제 p 요소를 선택 }
  - A + B : 형제 선택자, 형제 요소 중에 첫번째 형제 요소를 선택

  - ::after : 콘텐츠 영역 바로 뒤의 가상 요소를 선택
  - ::before : 콘텐츠 영역 바로 앞의 가상 요소를 선택
  - ::marker : <li> 나 <summary> 처럼 자동으로 생성된 리스트 마커를 선택, 기호나 숫자등이 포함된 가상 요소
  - ::placeholder : 텍스트 입력 컨트롤의 placeholder 를 선택
  - ::selection : 텍스트를 드래그 해서 선택한 부분의 선택자
  - ::backdrop - 최상위 레이어에 생성된 별도 레이어를 선택하는 선택자
  - :link - 아직 방문하지 않은 링크를 선택
  - :visited - 이미 방문한 링크를 선택
  - :hover - 요소에 마우스를 올려 놓았을 동안 선택
  - :active - 요소에 마우스를 올려놓고 누르고 있을 동안 선택 즉, 버튼을 누르고 있는 찰나의 경우 선택
  - :focus - 요소가 포커스 되었을 동안 선택,사용자가 탭키나 요소를 클릭하여 선택하여 활성화 된 상태
             어떤 부분이 현재 상호 작용이 가능한 상태인지 사용자에게 명확히 알려주는 역할을 함, input, textarea, a 등등
  - :focus-visible
  - :focus-within
  - :checked - 라디오 버튼과 체크박스가 체크된 상태일 때 선택
  - :disabled - 비활성화된 요소 선택
  - :enabled - 활성화된 요소 선택
  - :is() - 선택자 목록 중 하나라도 존재하면 선택, 괄호안의 선택자 목록 중 하나라도 존해하는지 확인 한 후 선택함, 쉼표로 여러 선택자를 구분함.
  - :where() - is() 와 동일하지만, 구체성 값이 없음
  - :has() - 관계 선태자 목록 중 있으면 선택
  - :not(X) - X 와 일치하지 않는 요소를 선택, 특정 선택자르 ㄹ제외한 나머지 요소를 선택할 때 사용
  - :lang(콘텐츠언어) - 콘텐츠 언어를 기반으로 요소를 선택
  - :root - 문서의 루트 요소(<html>)를 선택함, 최상위 요소를 선택한다는 의미로 글로벌 CSS 변수를 선언할 때 주로 사용
  - :first-child - 첫번째 자식 요소 선택
  - :last-child - 마지막 자식 요소 선택
  - :nth-child(n) - 자식 요소 중 n 번째 위치한 요소를 선택 (인덱스를 기반)
  - :nth-last-child(n) - 자식 요소 중 끝에서 부터 n 번째 위치한 요소를 선택 (인덱스 기반)
  - :nth-of-type(n) - 태그 이름을 기준으로 형제 요소들 중에서 n 번째 요소를 선택
  - :last-of-type - 태그 이름 기준으로 마지막 요소 선택
  - :first-of-type - 태그 이름 기준으로 첫번째 요소 선택
  - :nth-last-of-type(n) - 태그 이름 기준으로 끝에서 부터 n 번째 요소 선택
  - :only-of-type - 특정 유형의 형제 요소 중에서 그 유형을 기준으로 첫번째이자 마지막에 위치하는 유일한 (only, 단독) 요소를 선택함.


*/
@charset "UTF-8";

@import url('reset.css');

/* import */
@import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Archivo+Black&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Story+Script&display=swap');

@import url('https://fonts.googleapis.com/css2?family=Cute+Font&display=swap');

/*
  ! @font-face !

  --> font-weight (선택적) : 굵기 지정, 100 ~ 900  또는 normal, bold 로 지정할 수 있음, 사용권장, 400
  --> font-style (선택적) : normal, italic, oblique 등의 옵션이 있으며 명지적 사용 권장
  --> font-display (선택적) : auto(기본값), block, swap, fallback, optional
  --> unicode-range (선택적) : 전체 문자에 대한 글꼴을 다운로드 하는 것이 아니라 특정 문자 범위의 글꼴만 다운로드
    - 한글범위 : U+AC00-D7A3
    - 영문 알파벳 : U+0041-U+007A
    - 숫자 : U+0030-U+0039;
    - 특수문자 : U+0021-U+007E; //- 기호 및 특수문자
    - unicode-range: U+26;
    - unicode-range: U+4??; //- U+400 에서 U+4FF 까지
    - unicode-range: U+AC00-D7A3, U+0041-007A, U+0030-0039; //- 한글, 영문 알파벳, 숫자
  --> ...

  - WOFF2(Web Open Font Format 2) : 웹에서 글꼴을 사용할 때 가장 추천되는 파일 형식 중 하나.
    - 효율적인 압축
    - 브라우저 호환성 : 대부분의 최신 브라우저에서 WOFF2를 지원하므로 안전하게 사용할 수 있임
    - 서버 성능 최적화 : WOFF2 파일을 사용하면 웹 페이지의 로디 ㅇ시간을 단축시키도 대역폭 사용량을 줄일 수 있음.

*/

/* 콜디폰트 */
@font-face {
  font-family: 'Koldi';
  src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2508-2@1.0/Ownglyph_Coldywebtoonmaker-Rg.woff2')
    format('woff2');
  font-weight: normal;
  font-style: normal;
}

/* 영울 폰트 */
@font-face {
  font-family: 'Yeongwol';
  src: url('https://cdn.jsdelivr.net/gh/projectnoonnu/2507-2@1.0/YeongwolTTF-Regular.woff2')
    format('woff2');
  font-weight: normal;
  font-display: swap;
}

/*
  @support(속성: 값) {
  ...   지원되는 경우 선언할 스타일 ...
  }

  - 속성과 값의 조합 지원 여부에 사용되는 구문

*/

/* CSS 변수 */
:root {
  --primary-color: #8b008b;
  --happy-color: #00a0e9;
  --font-size: 2em;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

html {
  width: 100%;
  height: 100%;
}

body {
  margin: 0;
  padding: 1rem 0.5rem;
  /* font-family: 'Archivo Black', 'Cute Font', sans-serif; */
  font-family: 'Ubuntu', 'Cute Font', sans-serif;
  background-color: rgba(213, 98, 98, 0.2);
}

/*속성 선택자 */

#attribute-selection-demo {
  margin: 10px 0;
}
[title*='text'] {
  padding: 0 10px;
  color: green;
}
/* 가상 선택자 */
#before-after::before {
  content: '문단의 Before ( ';
  color: rgb(244, 142, 8);
}

#before-after::after {
  content: ' ) 문단의 After';
  color: rgb(244, 142, 8);
}

#before-after {
  border: 5px solid rgba(255, 0, 0, 0.5);
  padding: 1rem;
  margin: 1rem 0;
}
/* ::placeholder */
[class^='hello']::selection {
  color: red;
}

.hangle-font-koldi {
  font-family: 'koldi', sans-serif;
  font-size: 2rem;
  margin: 1rem 0;
}

.container {
  width: 100%;
  padding: 10px;
  background-color: rgba(202, 198, 198, 0.5);
}

.story-script {
  font-family: 'Story Script', sans-serif;
  font-weight: 400;
  font-style: normal;
}

/* 변수 사용, 대체칼라 */
/* var(--변수이름[, 대체 값]) */
#alt-var {
  font-size: 2em;
  color: var(--good-color, #3b3b8a);
}

#responsive-font-size {
  font-size: var(--font-size);
}

.two {
  --test: 10px;
}

.three {
  --test: 2em;
}

div {
  font-size: var(--test);
}

#before-item {
  width: 90%;
  height: 24px;
  background-color: rgba(255, 0, 0, 0.2);
}
#before-item::before {
  content: '🏋️‍♂️ ';
}

#before-item::after {
  content: ' ✨';
}

.demo-var {
  color: var(--primary-color);
}

h1 {
  font-family: 'Inter', sans-serif;
}

/* 반응형 설정 */
@media (max-width: 768px) {
  /* 작은 화면에서의 스타일 */
  header {
    background-color: #555;
  }
}

/* 반응형 변수 */
@media (max-width: 1024px) {
  :root {
    --font-size: 1em;
  }
}
